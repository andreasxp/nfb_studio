<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.1" />
<title>nfb_studio.scheme.node.edge API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>nfb_studio.scheme.node.edge</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from typing import Union

from PySide2.QtCore import QPointF, QRectF, QLineF
from PySide2.QtGui import QPainter, QPainterPath, QPen

from ..scheme_item import SchemeItem
from ..style import Style
from .node import Node
from .connection import Input, Output, Connection, DataType
from .connection.data_type import convertible


class Edge(SchemeItem):
    &#34;&#34;&#34;An graphics item representing a bezier curve, connecting one node&#39;s output to another&#39;s input.&#34;&#34;&#34;

    def __init__(self):
        super(Edge, self).__init__()
        self.setZValue(-1)  # Draw edges behind nodes
        self.setFlag(self.ItemIsSelectable)

        self._source: Union[Output, None] = None
        &#34;&#34;&#34;An edge is drawn from its source to its target. Node&#39;s output is edge&#39;s source.  
        This variable represents current source as a variable of type Output.
        &#34;&#34;&#34;
        self._target: Union[Input, None] = None
        &#34;&#34;&#34;An edge is drawn from its source to its target. Node&#39;s input is edge&#39;s target.  
        This variable represents current target as a variable of type Input.
        &#34;&#34;&#34;

        self._source_pos: Union[QPointF, None] = None
        &#34;&#34;&#34;An edge is drawn from its source to its target. Node&#39;s output is edge&#39;s source.  
        This variable represents current source coordinates in scene pixels.
        &#34;&#34;&#34;
        self._target_pos: Union[QPointF, None] = None
        &#34;&#34;&#34;An edge is drawn from its source to its target. Node&#39;s input is edge&#39;s target.  
        This variable represents current target coordinates in scene pixels.
        &#34;&#34;&#34;

        self._path = QPainterPath()
        self._pen = QPen()

        self.styleChange()
        self.paletteChange()

    # Observer functions ===============================================================================================
    def sourceNode(self) -&gt; Union[Node, None]:
        &#34;&#34;&#34;Return a node from which the edge originates, if it exists.  
        If the edge has no source connection, it consequently has no source node.
        &#34;&#34;&#34;
        if self.source():
            return self.source().parentItem()
        return None

    def targetNode(self) -&gt; Union[Node, None]:
        &#34;&#34;&#34;Return a node to which the edge goes, if it exists.  
        If the edge has no target connection, it consequently has no target node.
        &#34;&#34;&#34;
        if self.target():
            return self.target().parentItem()
        return None

    def source(self) -&gt; Union[Output, None]:
        &#34;&#34;&#34;Return an output connection from which the edge goes, if it exists.  
        Note that an edge can have a source pos (as in coordinates), but not a source connection.
        &#34;&#34;&#34;
        return self._source

    def target(self) -&gt; Union[Input, None]:
        &#34;&#34;&#34;Return an input connection to which the edge goes, if it exists.  
        Note that an edge can have a target pos (as in coordinates), but not a target connection.
        &#34;&#34;&#34;
        return self._target

    def sourcePos(self) -&gt; Union[QPointF, None]:
        &#34;&#34;&#34;Return this edge&#39;s source position, if it exists.  
        If the edge is connected to a node on the source side, node&#39;s output&#39;s coordinates is this position. If it is
        not connected but has a statis position set, that is returned. Otherwise, this function returns None.
        &#34;&#34;&#34;
        return self._source_pos

    def targetPos(self) -&gt; Union[QPointF, None]:
        &#34;&#34;&#34;Return this edge&#39;s source position, if it exists.  
        If the edge is connected to a node on the target side, node&#39;s input&#39;s coordinates is this position. If it is
        not connected but has a statis position set, that is returned. Otherwise, this function returns None.
        &#34;&#34;&#34;
        return self._source_pos

    def dataType(self) -&gt; Union[DataType, None]:
        &#34;&#34;&#34;Return this edge&#39;s data type.  
        By themselves, edges do not have a data type. However, if an edge is connected to something, it assumes that
        connection&#39;s data type as its own.  
        If the edge is not connected to anything, returns None.&#34;&#34;&#34;
        if self.source() is not None:
            return self.source().dataType()
        elif self.target() is not None:
            return self.target().dataType()
        
        return None

    # Setter functions =================================================================================================
    def attach(self, connection: Connection):
        &#34;&#34;&#34;Attach this edge to a connection.  
        This function is similar to setSource and setTarget, but determines which side to attach automatically.
        &#34;&#34;&#34;
        connection.attach(self)
    
    def detach(self, connection: Connection):
        &#34;&#34;&#34;Detach this edge from a connection.  
        This function is similar to setSource(None) and setTarget(None), but determines which side to detach
        automatically.
        &#34;&#34;&#34;
        connection.detach(self)
    
    def detachAll(self):
        &#34;&#34;&#34;Detach this edge from both source and target nodes.&#34;&#34;&#34;
        if self.source() is not None:
            self.setSource(None)
        
        if self.target() is not None:
            self.setTarget(None)

    def setTarget(self, target: Union[Input, None]):
        &#34;&#34;&#34;Set (or unset) the target of this edge.

        Unsetting the target sets the target position to None, which causes the edge to not be drawn, until another
        target (or target position) is supplied.
        &#34;&#34;&#34;
        if (self._target is not None) and (self._target is not target):
            # Remove self direcly from self._target.edges instead of calling self._target.detach
            # to prevent infinite recursion.
            self._target.edges.remove(self)

        if target is not None:
            target.edges.add(self)

        self._target = target
        self._target_pos = None

        self.checkDataType()
        self.adjust()

    def setSource(self, source: Union[Output, None]):
        &#34;&#34;&#34;Set (or unset) the source of this edge.

        Unsetting the source sets the source position to None, which causes the edge to not be drawn, until another
        source (or source position) is supplied.
        &#34;&#34;&#34;
        if (self._source is not None) and (self._source is not source):
            # Remove self direcly from self._target.edges instead of calling self._target.detach
            # to prevent infinite recursion.
            self._source.edges.remove(self)

        if source is not None:
            source.edges.add(self)

        self._source = source
        self._source_pos = None  # Is set to None in case source is None. If needed, will be changed by adjust()

        self.checkDataType()
        self.adjust()

    def setTargetPos(self, pos: QPointF):
        &#34;&#34;&#34;Set target position not from a target connection, but to some static coordinates.

        Useful when drawing an edge to the tip of the mouse. This function sets edge&#39;s target to None.
        pos is in scene pixel coordinates.
        &#34;&#34;&#34;
        self._target = None
        self._target_pos = pos

        self.adjust()

    def setSourcePos(self, pos: QPointF):
        &#34;&#34;&#34;Set source position not from a source connection, but to some static coordinates.

        Useful when drawing an edge to the tip of the mouse. This function sets edge&#39;s source to None.
        pos is in scene pixel coordinates.
        &#34;&#34;&#34;
        self._source = None
        self._source_pos = pos

        self.adjust()

    # Geometry and drawing =============================================================================================
    def path(self):
        &#34;&#34;&#34;Compute and return QPainterPath that is used to draw the curved line.  
        Internal function use this to reset their path in response to external changes. 
        &#34;&#34;&#34;
        if self._source_pos is None or self._target_pos is None:
            return QPainterPath()
        
        result = QPainterPath()
        result.moveTo(self._source_pos)
        result.cubicTo(self._bezier_point_1(), self._bezier_point_2(), self._target_pos)
        
        return result

    def _bezier_offset(self) -&gt; QPointF:
        &#34;&#34;&#34;Symmetric offset of a control point from source/target.
        
        Bezier calculation functions assume that sourcePos() and targetPos() are not None.
        &#34;&#34;&#34;
        close_distance = self.style().pixelMetric(Style.EdgeBezierCloseDistance)
        point_offset = self.style().pixelMetric(Style.EdgeBezierPointOffset)

        closeness_factor = min(
            QLineF(self._source_pos, self._target_pos).length() / close_distance,
            1
        )

        return QPointF(point_offset, 0) * closeness_factor

    def _bezier_point_1(self) -&gt; QPointF:
        &#34;&#34;&#34;Bezier control point 1 for drawing the edge on the screen.
        
        Bezier calculation functions assume that sourcePos() and targetPos() are not None.
        &#34;&#34;&#34;
        return self._source_pos + self._bezier_offset()

    def _bezier_point_2(self) -&gt; QPointF:
        &#34;&#34;&#34;Bezier control point 2 for drawing the edge on the screen.
        
        Bezier calculation functions assume that sourcePos() and targetPos() are not None.
        &#34;&#34;&#34;
        return self._target_pos - self._bezier_offset()

    def boundingRect(self) -&gt; QRectF:
        if self._source_pos is None or self._target_pos is None:
            return QRectF()

        edge_width = self.style().pixelMetric(Style.EdgeWidth)

        return self._path.boundingRect().adjusted(0, -edge_width/2, 0, edge_width/2)

    def shape(self) -&gt; QPainterPath:
        return self._path

    def paint(self, painter: QPainter, option, widget=...) -&gt; None:
        if self._source_pos is None or self._target_pos is None:
            return

        painter.setPen(self._pen)
        painter.drawPath(self._path)

    # Utility functions ================================================================================================
    def adjust(self):
        &#34;&#34;&#34;Adjust the edge&#39;s coordinates to match those of the input and output of nodes.  
        Call this function if the node moved or source/target was changed.
        &#34;&#34;&#34;
        self.setPos(0, 0)  # Edge is always at position 0
        self.prepareGeometryChange()
        
        if self._source is not None:
            self._source_pos = self._source.mapToScene(self._source.stemTip())

        if self._target is not None:
            self._target_pos = self._target.mapToScene(self._target.stemTip())

        self._path = self.path()  # Recompute path
    
    def checkDataType(self):
        &#34;&#34;&#34;Check if the data type of two connections matches and raise a ValueError if it does not.&#34;&#34;&#34;
        if self._source is None or self._target is None:
            return

        if not convertible(self._source.dataType(), self._target.dataType()):
            raise ValueError(
                &#34;data types of connections (\&#34;{}\&#34; and \&#34;{}\&#34;) are not compatible&#34;.format(
                    str(self._source.dataType()),
                    str(self._target.dataType())
                )
            )

    # Events ===========================================================================================================
    def itemChange(self, change, value):
        # ItemSelectedChange -------------------------------------------------------------------------------------------
        # When a selection change is requested, ensure that an edge can be selected on it&#39;s own. Otherwise, follow
        # autoSelect policy.
        if change == self.ItemSelectedChange:
            scheme = self.scene()

            if len(scheme.selection().nodes) != 0:
                # If nodes are selected, edges are allowed to be selected only between two nodes. 
                value = self._autoSelectValue()
        # ItemSelectedHasChanged ---------------------------------------------------------------------------------------
        # When a selection status has changed, propagate it to connections on both sides.
        elif change == self.ItemSelectedHasChanged:
            if self.source() is not None and self.source().isSelected() != value:
                self.source().autoSelectFromEdge()

            if self.target() is not None and self.target().isSelected() != value:
                self.target().autoSelectFromEdge()

        return super().itemChange(change, value)
    
    def autoSelect(self):
        &#34;&#34;&#34;Automatically determine if the edge needs to be selected or not.  
        This function considers edge selected if nodes on both ends are selected.
        &#34;&#34;&#34;
        self.setSelected(self._autoSelectValue())

    def _autoSelectValue(self) -&gt; bool:
        &#34;&#34;&#34;Value of selection when autoselecting.&#34;&#34;&#34;
        return (
            self.sourceNode() is not None and
            self.targetNode() is not None and
            self.sourceNode().isSelected() and
            self.targetNode().isSelected()
        )

    # Style and palette ================================================================================================
    def styleChange(self):
        super().styleChange()
        self.prepareGeometryChange()
        style = self.style()

        self._pen = style.edgePen(self.palette())
        self._path = self.path()  # Recompute path with new parameters
        
    def paletteChange(self):
        self._pen = self.style().edgePen(self.palette())

        self.update(self.boundingRect())</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="nfb_studio.scheme.node.edge.Edge"><code class="flex name class">
<span>class <span class="ident">Edge</span></span>
</code></dt>
<dd>
<div class="desc"><p>An graphics item representing a bezier curve, connecting one node's output to another's input.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Edge(SchemeItem):
    &#34;&#34;&#34;An graphics item representing a bezier curve, connecting one node&#39;s output to another&#39;s input.&#34;&#34;&#34;

    def __init__(self):
        super(Edge, self).__init__()
        self.setZValue(-1)  # Draw edges behind nodes
        self.setFlag(self.ItemIsSelectable)

        self._source: Union[Output, None] = None
        &#34;&#34;&#34;An edge is drawn from its source to its target. Node&#39;s output is edge&#39;s source.  
        This variable represents current source as a variable of type Output.
        &#34;&#34;&#34;
        self._target: Union[Input, None] = None
        &#34;&#34;&#34;An edge is drawn from its source to its target. Node&#39;s input is edge&#39;s target.  
        This variable represents current target as a variable of type Input.
        &#34;&#34;&#34;

        self._source_pos: Union[QPointF, None] = None
        &#34;&#34;&#34;An edge is drawn from its source to its target. Node&#39;s output is edge&#39;s source.  
        This variable represents current source coordinates in scene pixels.
        &#34;&#34;&#34;
        self._target_pos: Union[QPointF, None] = None
        &#34;&#34;&#34;An edge is drawn from its source to its target. Node&#39;s input is edge&#39;s target.  
        This variable represents current target coordinates in scene pixels.
        &#34;&#34;&#34;

        self._path = QPainterPath()
        self._pen = QPen()

        self.styleChange()
        self.paletteChange()

    # Observer functions ===============================================================================================
    def sourceNode(self) -&gt; Union[Node, None]:
        &#34;&#34;&#34;Return a node from which the edge originates, if it exists.  
        If the edge has no source connection, it consequently has no source node.
        &#34;&#34;&#34;
        if self.source():
            return self.source().parentItem()
        return None

    def targetNode(self) -&gt; Union[Node, None]:
        &#34;&#34;&#34;Return a node to which the edge goes, if it exists.  
        If the edge has no target connection, it consequently has no target node.
        &#34;&#34;&#34;
        if self.target():
            return self.target().parentItem()
        return None

    def source(self) -&gt; Union[Output, None]:
        &#34;&#34;&#34;Return an output connection from which the edge goes, if it exists.  
        Note that an edge can have a source pos (as in coordinates), but not a source connection.
        &#34;&#34;&#34;
        return self._source

    def target(self) -&gt; Union[Input, None]:
        &#34;&#34;&#34;Return an input connection to which the edge goes, if it exists.  
        Note that an edge can have a target pos (as in coordinates), but not a target connection.
        &#34;&#34;&#34;
        return self._target

    def sourcePos(self) -&gt; Union[QPointF, None]:
        &#34;&#34;&#34;Return this edge&#39;s source position, if it exists.  
        If the edge is connected to a node on the source side, node&#39;s output&#39;s coordinates is this position. If it is
        not connected but has a statis position set, that is returned. Otherwise, this function returns None.
        &#34;&#34;&#34;
        return self._source_pos

    def targetPos(self) -&gt; Union[QPointF, None]:
        &#34;&#34;&#34;Return this edge&#39;s source position, if it exists.  
        If the edge is connected to a node on the target side, node&#39;s input&#39;s coordinates is this position. If it is
        not connected but has a statis position set, that is returned. Otherwise, this function returns None.
        &#34;&#34;&#34;
        return self._source_pos

    def dataType(self) -&gt; Union[DataType, None]:
        &#34;&#34;&#34;Return this edge&#39;s data type.  
        By themselves, edges do not have a data type. However, if an edge is connected to something, it assumes that
        connection&#39;s data type as its own.  
        If the edge is not connected to anything, returns None.&#34;&#34;&#34;
        if self.source() is not None:
            return self.source().dataType()
        elif self.target() is not None:
            return self.target().dataType()
        
        return None

    # Setter functions =================================================================================================
    def attach(self, connection: Connection):
        &#34;&#34;&#34;Attach this edge to a connection.  
        This function is similar to setSource and setTarget, but determines which side to attach automatically.
        &#34;&#34;&#34;
        connection.attach(self)
    
    def detach(self, connection: Connection):
        &#34;&#34;&#34;Detach this edge from a connection.  
        This function is similar to setSource(None) and setTarget(None), but determines which side to detach
        automatically.
        &#34;&#34;&#34;
        connection.detach(self)
    
    def detachAll(self):
        &#34;&#34;&#34;Detach this edge from both source and target nodes.&#34;&#34;&#34;
        if self.source() is not None:
            self.setSource(None)
        
        if self.target() is not None:
            self.setTarget(None)

    def setTarget(self, target: Union[Input, None]):
        &#34;&#34;&#34;Set (or unset) the target of this edge.

        Unsetting the target sets the target position to None, which causes the edge to not be drawn, until another
        target (or target position) is supplied.
        &#34;&#34;&#34;
        if (self._target is not None) and (self._target is not target):
            # Remove self direcly from self._target.edges instead of calling self._target.detach
            # to prevent infinite recursion.
            self._target.edges.remove(self)

        if target is not None:
            target.edges.add(self)

        self._target = target
        self._target_pos = None

        self.checkDataType()
        self.adjust()

    def setSource(self, source: Union[Output, None]):
        &#34;&#34;&#34;Set (or unset) the source of this edge.

        Unsetting the source sets the source position to None, which causes the edge to not be drawn, until another
        source (or source position) is supplied.
        &#34;&#34;&#34;
        if (self._source is not None) and (self._source is not source):
            # Remove self direcly from self._target.edges instead of calling self._target.detach
            # to prevent infinite recursion.
            self._source.edges.remove(self)

        if source is not None:
            source.edges.add(self)

        self._source = source
        self._source_pos = None  # Is set to None in case source is None. If needed, will be changed by adjust()

        self.checkDataType()
        self.adjust()

    def setTargetPos(self, pos: QPointF):
        &#34;&#34;&#34;Set target position not from a target connection, but to some static coordinates.

        Useful when drawing an edge to the tip of the mouse. This function sets edge&#39;s target to None.
        pos is in scene pixel coordinates.
        &#34;&#34;&#34;
        self._target = None
        self._target_pos = pos

        self.adjust()

    def setSourcePos(self, pos: QPointF):
        &#34;&#34;&#34;Set source position not from a source connection, but to some static coordinates.

        Useful when drawing an edge to the tip of the mouse. This function sets edge&#39;s source to None.
        pos is in scene pixel coordinates.
        &#34;&#34;&#34;
        self._source = None
        self._source_pos = pos

        self.adjust()

    # Geometry and drawing =============================================================================================
    def path(self):
        &#34;&#34;&#34;Compute and return QPainterPath that is used to draw the curved line.  
        Internal function use this to reset their path in response to external changes. 
        &#34;&#34;&#34;
        if self._source_pos is None or self._target_pos is None:
            return QPainterPath()
        
        result = QPainterPath()
        result.moveTo(self._source_pos)
        result.cubicTo(self._bezier_point_1(), self._bezier_point_2(), self._target_pos)
        
        return result

    def _bezier_offset(self) -&gt; QPointF:
        &#34;&#34;&#34;Symmetric offset of a control point from source/target.
        
        Bezier calculation functions assume that sourcePos() and targetPos() are not None.
        &#34;&#34;&#34;
        close_distance = self.style().pixelMetric(Style.EdgeBezierCloseDistance)
        point_offset = self.style().pixelMetric(Style.EdgeBezierPointOffset)

        closeness_factor = min(
            QLineF(self._source_pos, self._target_pos).length() / close_distance,
            1
        )

        return QPointF(point_offset, 0) * closeness_factor

    def _bezier_point_1(self) -&gt; QPointF:
        &#34;&#34;&#34;Bezier control point 1 for drawing the edge on the screen.
        
        Bezier calculation functions assume that sourcePos() and targetPos() are not None.
        &#34;&#34;&#34;
        return self._source_pos + self._bezier_offset()

    def _bezier_point_2(self) -&gt; QPointF:
        &#34;&#34;&#34;Bezier control point 2 for drawing the edge on the screen.
        
        Bezier calculation functions assume that sourcePos() and targetPos() are not None.
        &#34;&#34;&#34;
        return self._target_pos - self._bezier_offset()

    def boundingRect(self) -&gt; QRectF:
        if self._source_pos is None or self._target_pos is None:
            return QRectF()

        edge_width = self.style().pixelMetric(Style.EdgeWidth)

        return self._path.boundingRect().adjusted(0, -edge_width/2, 0, edge_width/2)

    def shape(self) -&gt; QPainterPath:
        return self._path

    def paint(self, painter: QPainter, option, widget=...) -&gt; None:
        if self._source_pos is None or self._target_pos is None:
            return

        painter.setPen(self._pen)
        painter.drawPath(self._path)

    # Utility functions ================================================================================================
    def adjust(self):
        &#34;&#34;&#34;Adjust the edge&#39;s coordinates to match those of the input and output of nodes.  
        Call this function if the node moved or source/target was changed.
        &#34;&#34;&#34;
        self.setPos(0, 0)  # Edge is always at position 0
        self.prepareGeometryChange()
        
        if self._source is not None:
            self._source_pos = self._source.mapToScene(self._source.stemTip())

        if self._target is not None:
            self._target_pos = self._target.mapToScene(self._target.stemTip())

        self._path = self.path()  # Recompute path
    
    def checkDataType(self):
        &#34;&#34;&#34;Check if the data type of two connections matches and raise a ValueError if it does not.&#34;&#34;&#34;
        if self._source is None or self._target is None:
            return

        if not convertible(self._source.dataType(), self._target.dataType()):
            raise ValueError(
                &#34;data types of connections (\&#34;{}\&#34; and \&#34;{}\&#34;) are not compatible&#34;.format(
                    str(self._source.dataType()),
                    str(self._target.dataType())
                )
            )

    # Events ===========================================================================================================
    def itemChange(self, change, value):
        # ItemSelectedChange -------------------------------------------------------------------------------------------
        # When a selection change is requested, ensure that an edge can be selected on it&#39;s own. Otherwise, follow
        # autoSelect policy.
        if change == self.ItemSelectedChange:
            scheme = self.scene()

            if len(scheme.selection().nodes) != 0:
                # If nodes are selected, edges are allowed to be selected only between two nodes. 
                value = self._autoSelectValue()
        # ItemSelectedHasChanged ---------------------------------------------------------------------------------------
        # When a selection status has changed, propagate it to connections on both sides.
        elif change == self.ItemSelectedHasChanged:
            if self.source() is not None and self.source().isSelected() != value:
                self.source().autoSelectFromEdge()

            if self.target() is not None and self.target().isSelected() != value:
                self.target().autoSelectFromEdge()

        return super().itemChange(change, value)
    
    def autoSelect(self):
        &#34;&#34;&#34;Automatically determine if the edge needs to be selected or not.  
        This function considers edge selected if nodes on both ends are selected.
        &#34;&#34;&#34;
        self.setSelected(self._autoSelectValue())

    def _autoSelectValue(self) -&gt; bool:
        &#34;&#34;&#34;Value of selection when autoselecting.&#34;&#34;&#34;
        return (
            self.sourceNode() is not None and
            self.targetNode() is not None and
            self.sourceNode().isSelected() and
            self.targetNode().isSelected()
        )

    # Style and palette ================================================================================================
    def styleChange(self):
        super().styleChange()
        self.prepareGeometryChange()
        style = self.style()

        self._pen = style.edgePen(self.palette())
        self._path = self.path()  # Recompute path with new parameters
        
    def paletteChange(self):
        self._pen = self.style().edgePen(self.palette())

        self.update(self.boundingRect())</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="nfb_studio.scheme.scheme_item.SchemeItem" href="../scheme_item.html#nfb_studio.scheme.scheme_item.SchemeItem">SchemeItem</a></li>
<li>PySide2.QtWidgets.QGraphicsItem</li>
<li>Shiboken.Object</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="nfb_studio.scheme.node.edge.Edge.adjust"><code class="name flex">
<span>def <span class="ident">adjust</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Adjust the edge's coordinates to match those of the input and output of nodes.<br>
Call this function if the node moved or source/target was changed.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def adjust(self):
    &#34;&#34;&#34;Adjust the edge&#39;s coordinates to match those of the input and output of nodes.  
    Call this function if the node moved or source/target was changed.
    &#34;&#34;&#34;
    self.setPos(0, 0)  # Edge is always at position 0
    self.prepareGeometryChange()
    
    if self._source is not None:
        self._source_pos = self._source.mapToScene(self._source.stemTip())

    if self._target is not None:
        self._target_pos = self._target.mapToScene(self._target.stemTip())

    self._path = self.path()  # Recompute path</code></pre>
</details>
</dd>
<dt id="nfb_studio.scheme.node.edge.Edge.attach"><code class="name flex">
<span>def <span class="ident">attach</span></span>(<span>self, connection: <a title="nfb_studio.scheme.node.connection.connection.Connection" href="connection/connection.html#nfb_studio.scheme.node.connection.connection.Connection">Connection</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Attach this edge to a connection.<br>
This function is similar to setSource and setTarget, but determines which side to attach automatically.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def attach(self, connection: Connection):
    &#34;&#34;&#34;Attach this edge to a connection.  
    This function is similar to setSource and setTarget, but determines which side to attach automatically.
    &#34;&#34;&#34;
    connection.attach(self)</code></pre>
</details>
</dd>
<dt id="nfb_studio.scheme.node.edge.Edge.autoSelect"><code class="name flex">
<span>def <span class="ident">autoSelect</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Automatically determine if the edge needs to be selected or not.<br>
This function considers edge selected if nodes on both ends are selected.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def autoSelect(self):
    &#34;&#34;&#34;Automatically determine if the edge needs to be selected or not.  
    This function considers edge selected if nodes on both ends are selected.
    &#34;&#34;&#34;
    self.setSelected(self._autoSelectValue())</code></pre>
</details>
</dd>
<dt id="nfb_studio.scheme.node.edge.Edge.boundingRect"><code class="name flex">
<span>def <span class="ident">boundingRect</span></span>(<span>self) ‑> PySide2.QtCore.QRectF</span>
</code></dt>
<dd>
<div class="desc"><p>boundingRect(self) -&gt; PySide2.QtCore.QRectF</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def boundingRect(self) -&gt; QRectF:
    if self._source_pos is None or self._target_pos is None:
        return QRectF()

    edge_width = self.style().pixelMetric(Style.EdgeWidth)

    return self._path.boundingRect().adjusted(0, -edge_width/2, 0, edge_width/2)</code></pre>
</details>
</dd>
<dt id="nfb_studio.scheme.node.edge.Edge.checkDataType"><code class="name flex">
<span>def <span class="ident">checkDataType</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Check if the data type of two connections matches and raise a ValueError if it does not.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def checkDataType(self):
    &#34;&#34;&#34;Check if the data type of two connections matches and raise a ValueError if it does not.&#34;&#34;&#34;
    if self._source is None or self._target is None:
        return

    if not convertible(self._source.dataType(), self._target.dataType()):
        raise ValueError(
            &#34;data types of connections (\&#34;{}\&#34; and \&#34;{}\&#34;) are not compatible&#34;.format(
                str(self._source.dataType()),
                str(self._target.dataType())
            )
        )</code></pre>
</details>
</dd>
<dt id="nfb_studio.scheme.node.edge.Edge.dataType"><code class="name flex">
<span>def <span class="ident">dataType</span></span>(<span>self) ‑> typing.Union[<a title="nfb_studio.scheme.node.connection.data_type.DataType" href="connection/data_type.html#nfb_studio.scheme.node.connection.data_type.DataType">DataType</a>, NoneType]</span>
</code></dt>
<dd>
<div class="desc"><p>Return this edge's data type.<br>
By themselves, edges do not have a data type. However, if an edge is connected to something, it assumes that
connection's data type as its own.<br>
If the edge is not connected to anything, returns None.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dataType(self) -&gt; Union[DataType, None]:
    &#34;&#34;&#34;Return this edge&#39;s data type.  
    By themselves, edges do not have a data type. However, if an edge is connected to something, it assumes that
    connection&#39;s data type as its own.  
    If the edge is not connected to anything, returns None.&#34;&#34;&#34;
    if self.source() is not None:
        return self.source().dataType()
    elif self.target() is not None:
        return self.target().dataType()
    
    return None</code></pre>
</details>
</dd>
<dt id="nfb_studio.scheme.node.edge.Edge.detach"><code class="name flex">
<span>def <span class="ident">detach</span></span>(<span>self, connection: <a title="nfb_studio.scheme.node.connection.connection.Connection" href="connection/connection.html#nfb_studio.scheme.node.connection.connection.Connection">Connection</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Detach this edge from a connection.<br>
This function is similar to setSource(None) and setTarget(None), but determines which side to detach
automatically.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def detach(self, connection: Connection):
    &#34;&#34;&#34;Detach this edge from a connection.  
    This function is similar to setSource(None) and setTarget(None), but determines which side to detach
    automatically.
    &#34;&#34;&#34;
    connection.detach(self)</code></pre>
</details>
</dd>
<dt id="nfb_studio.scheme.node.edge.Edge.detachAll"><code class="name flex">
<span>def <span class="ident">detachAll</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Detach this edge from both source and target nodes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def detachAll(self):
    &#34;&#34;&#34;Detach this edge from both source and target nodes.&#34;&#34;&#34;
    if self.source() is not None:
        self.setSource(None)
    
    if self.target() is not None:
        self.setTarget(None)</code></pre>
</details>
</dd>
<dt id="nfb_studio.scheme.node.edge.Edge.paint"><code class="name flex">
<span>def <span class="ident">paint</span></span>(<span>self, painter: PySide2.QtGui.QPainter, option, widget=Ellipsis) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>paint(self, painter: PySide2.QtGui.QPainter, option: PySide2.QtWidgets.QStyleOptionGraphicsItem, widget: typing.Union[PySide2.QtWidgets.QWidget, NoneType] = None)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def paint(self, painter: QPainter, option, widget=...) -&gt; None:
    if self._source_pos is None or self._target_pos is None:
        return

    painter.setPen(self._pen)
    painter.drawPath(self._path)</code></pre>
</details>
</dd>
<dt id="nfb_studio.scheme.node.edge.Edge.paletteChange"><code class="name flex">
<span>def <span class="ident">paletteChange</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def paletteChange(self):
    self._pen = self.style().edgePen(self.palette())

    self.update(self.boundingRect())</code></pre>
</details>
</dd>
<dt id="nfb_studio.scheme.node.edge.Edge.path"><code class="name flex">
<span>def <span class="ident">path</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Compute and return QPainterPath that is used to draw the curved line.<br>
Internal function use this to reset their path in response to external changes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def path(self):
    &#34;&#34;&#34;Compute and return QPainterPath that is used to draw the curved line.  
    Internal function use this to reset their path in response to external changes. 
    &#34;&#34;&#34;
    if self._source_pos is None or self._target_pos is None:
        return QPainterPath()
    
    result = QPainterPath()
    result.moveTo(self._source_pos)
    result.cubicTo(self._bezier_point_1(), self._bezier_point_2(), self._target_pos)
    
    return result</code></pre>
</details>
</dd>
<dt id="nfb_studio.scheme.node.edge.Edge.setSource"><code class="name flex">
<span>def <span class="ident">setSource</span></span>(<span>self, source: typing.Union[<a title="nfb_studio.scheme.node.connection.output.Output" href="connection/output.html#nfb_studio.scheme.node.connection.output.Output">Output</a>, NoneType])</span>
</code></dt>
<dd>
<div class="desc"><p>Set (or unset) the source of this edge.</p>
<p>Unsetting the source sets the source position to None, which causes the edge to not be drawn, until another
source (or source position) is supplied.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setSource(self, source: Union[Output, None]):
    &#34;&#34;&#34;Set (or unset) the source of this edge.

    Unsetting the source sets the source position to None, which causes the edge to not be drawn, until another
    source (or source position) is supplied.
    &#34;&#34;&#34;
    if (self._source is not None) and (self._source is not source):
        # Remove self direcly from self._target.edges instead of calling self._target.detach
        # to prevent infinite recursion.
        self._source.edges.remove(self)

    if source is not None:
        source.edges.add(self)

    self._source = source
    self._source_pos = None  # Is set to None in case source is None. If needed, will be changed by adjust()

    self.checkDataType()
    self.adjust()</code></pre>
</details>
</dd>
<dt id="nfb_studio.scheme.node.edge.Edge.setSourcePos"><code class="name flex">
<span>def <span class="ident">setSourcePos</span></span>(<span>self, pos: PySide2.QtCore.QPointF)</span>
</code></dt>
<dd>
<div class="desc"><p>Set source position not from a source connection, but to some static coordinates.</p>
<p>Useful when drawing an edge to the tip of the mouse. This function sets edge's source to None.
pos is in scene pixel coordinates.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setSourcePos(self, pos: QPointF):
    &#34;&#34;&#34;Set source position not from a source connection, but to some static coordinates.

    Useful when drawing an edge to the tip of the mouse. This function sets edge&#39;s source to None.
    pos is in scene pixel coordinates.
    &#34;&#34;&#34;
    self._source = None
    self._source_pos = pos

    self.adjust()</code></pre>
</details>
</dd>
<dt id="nfb_studio.scheme.node.edge.Edge.setTarget"><code class="name flex">
<span>def <span class="ident">setTarget</span></span>(<span>self, target: typing.Union[<a title="nfb_studio.scheme.node.connection.input.Input" href="connection/input.html#nfb_studio.scheme.node.connection.input.Input">Input</a>, NoneType])</span>
</code></dt>
<dd>
<div class="desc"><p>Set (or unset) the target of this edge.</p>
<p>Unsetting the target sets the target position to None, which causes the edge to not be drawn, until another
target (or target position) is supplied.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setTarget(self, target: Union[Input, None]):
    &#34;&#34;&#34;Set (or unset) the target of this edge.

    Unsetting the target sets the target position to None, which causes the edge to not be drawn, until another
    target (or target position) is supplied.
    &#34;&#34;&#34;
    if (self._target is not None) and (self._target is not target):
        # Remove self direcly from self._target.edges instead of calling self._target.detach
        # to prevent infinite recursion.
        self._target.edges.remove(self)

    if target is not None:
        target.edges.add(self)

    self._target = target
    self._target_pos = None

    self.checkDataType()
    self.adjust()</code></pre>
</details>
</dd>
<dt id="nfb_studio.scheme.node.edge.Edge.setTargetPos"><code class="name flex">
<span>def <span class="ident">setTargetPos</span></span>(<span>self, pos: PySide2.QtCore.QPointF)</span>
</code></dt>
<dd>
<div class="desc"><p>Set target position not from a target connection, but to some static coordinates.</p>
<p>Useful when drawing an edge to the tip of the mouse. This function sets edge's target to None.
pos is in scene pixel coordinates.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setTargetPos(self, pos: QPointF):
    &#34;&#34;&#34;Set target position not from a target connection, but to some static coordinates.

    Useful when drawing an edge to the tip of the mouse. This function sets edge&#39;s target to None.
    pos is in scene pixel coordinates.
    &#34;&#34;&#34;
    self._target = None
    self._target_pos = pos

    self.adjust()</code></pre>
</details>
</dd>
<dt id="nfb_studio.scheme.node.edge.Edge.shape"><code class="name flex">
<span>def <span class="ident">shape</span></span>(<span>self) ‑> PySide2.QtGui.QPainterPath</span>
</code></dt>
<dd>
<div class="desc"><p>shape(self) -&gt; PySide2.QtGui.QPainterPath</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def shape(self) -&gt; QPainterPath:
    return self._path</code></pre>
</details>
</dd>
<dt id="nfb_studio.scheme.node.edge.Edge.source"><code class="name flex">
<span>def <span class="ident">source</span></span>(<span>self) ‑> typing.Union[<a title="nfb_studio.scheme.node.connection.output.Output" href="connection/output.html#nfb_studio.scheme.node.connection.output.Output">Output</a>, NoneType]</span>
</code></dt>
<dd>
<div class="desc"><p>Return an output connection from which the edge goes, if it exists.<br>
Note that an edge can have a source pos (as in coordinates), but not a source connection.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def source(self) -&gt; Union[Output, None]:
    &#34;&#34;&#34;Return an output connection from which the edge goes, if it exists.  
    Note that an edge can have a source pos (as in coordinates), but not a source connection.
    &#34;&#34;&#34;
    return self._source</code></pre>
</details>
</dd>
<dt id="nfb_studio.scheme.node.edge.Edge.sourceNode"><code class="name flex">
<span>def <span class="ident">sourceNode</span></span>(<span>self) ‑> typing.Union[<a title="nfb_studio.scheme.node.node.Node" href="node.html#nfb_studio.scheme.node.node.Node">Node</a>, NoneType]</span>
</code></dt>
<dd>
<div class="desc"><p>Return a node from which the edge originates, if it exists.<br>
If the edge has no source connection, it consequently has no source node.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sourceNode(self) -&gt; Union[Node, None]:
    &#34;&#34;&#34;Return a node from which the edge originates, if it exists.  
    If the edge has no source connection, it consequently has no source node.
    &#34;&#34;&#34;
    if self.source():
        return self.source().parentItem()
    return None</code></pre>
</details>
</dd>
<dt id="nfb_studio.scheme.node.edge.Edge.sourcePos"><code class="name flex">
<span>def <span class="ident">sourcePos</span></span>(<span>self) ‑> typing.Union[PySide2.QtCore.QPointF, NoneType]</span>
</code></dt>
<dd>
<div class="desc"><p>Return this edge's source position, if it exists.<br>
If the edge is connected to a node on the source side, node's output's coordinates is this position. If it is
not connected but has a statis position set, that is returned. Otherwise, this function returns None.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sourcePos(self) -&gt; Union[QPointF, None]:
    &#34;&#34;&#34;Return this edge&#39;s source position, if it exists.  
    If the edge is connected to a node on the source side, node&#39;s output&#39;s coordinates is this position. If it is
    not connected but has a statis position set, that is returned. Otherwise, this function returns None.
    &#34;&#34;&#34;
    return self._source_pos</code></pre>
</details>
</dd>
<dt id="nfb_studio.scheme.node.edge.Edge.styleChange"><code class="name flex">
<span>def <span class="ident">styleChange</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def styleChange(self):
    super().styleChange()
    self.prepareGeometryChange()
    style = self.style()

    self._pen = style.edgePen(self.palette())
    self._path = self.path()  # Recompute path with new parameters</code></pre>
</details>
</dd>
<dt id="nfb_studio.scheme.node.edge.Edge.target"><code class="name flex">
<span>def <span class="ident">target</span></span>(<span>self) ‑> typing.Union[<a title="nfb_studio.scheme.node.connection.input.Input" href="connection/input.html#nfb_studio.scheme.node.connection.input.Input">Input</a>, NoneType]</span>
</code></dt>
<dd>
<div class="desc"><p>Return an input connection to which the edge goes, if it exists.<br>
Note that an edge can have a target pos (as in coordinates), but not a target connection.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def target(self) -&gt; Union[Input, None]:
    &#34;&#34;&#34;Return an input connection to which the edge goes, if it exists.  
    Note that an edge can have a target pos (as in coordinates), but not a target connection.
    &#34;&#34;&#34;
    return self._target</code></pre>
</details>
</dd>
<dt id="nfb_studio.scheme.node.edge.Edge.targetNode"><code class="name flex">
<span>def <span class="ident">targetNode</span></span>(<span>self) ‑> typing.Union[<a title="nfb_studio.scheme.node.node.Node" href="node.html#nfb_studio.scheme.node.node.Node">Node</a>, NoneType]</span>
</code></dt>
<dd>
<div class="desc"><p>Return a node to which the edge goes, if it exists.<br>
If the edge has no target connection, it consequently has no target node.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def targetNode(self) -&gt; Union[Node, None]:
    &#34;&#34;&#34;Return a node to which the edge goes, if it exists.  
    If the edge has no target connection, it consequently has no target node.
    &#34;&#34;&#34;
    if self.target():
        return self.target().parentItem()
    return None</code></pre>
</details>
</dd>
<dt id="nfb_studio.scheme.node.edge.Edge.targetPos"><code class="name flex">
<span>def <span class="ident">targetPos</span></span>(<span>self) ‑> typing.Union[PySide2.QtCore.QPointF, NoneType]</span>
</code></dt>
<dd>
<div class="desc"><p>Return this edge's source position, if it exists.<br>
If the edge is connected to a node on the target side, node's input's coordinates is this position. If it is
not connected but has a statis position set, that is returned. Otherwise, this function returns None.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def targetPos(self) -&gt; Union[QPointF, None]:
    &#34;&#34;&#34;Return this edge&#39;s source position, if it exists.  
    If the edge is connected to a node on the target side, node&#39;s input&#39;s coordinates is this position. If it is
    not connected but has a statis position set, that is returned. Otherwise, this function returns None.
    &#34;&#34;&#34;
    return self._source_pos</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="nfb_studio.scheme.scheme_item.SchemeItem" href="../scheme_item.html#nfb_studio.scheme.scheme_item.SchemeItem">SchemeItem</a></b></code>:
<ul class="hlist">
<li><code><a title="nfb_studio.scheme.scheme_item.SchemeItem.itemChange" href="../scheme_item.html#nfb_studio.scheme.scheme_item.SchemeItem.itemChange">itemChange</a></code></li>
<li><code><a title="nfb_studio.scheme.scheme_item.SchemeItem.position" href="../scheme_item.html#nfb_studio.scheme.scheme_item.SchemeItem.position">position</a></code></li>
<li><code><a title="nfb_studio.scheme.scheme_item.SchemeItem.setPosition" href="../scheme_item.html#nfb_studio.scheme.scheme_item.SchemeItem.setPosition">setPosition</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="nfb_studio.scheme.node" href="index.html">nfb_studio.scheme.node</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="nfb_studio.scheme.node.edge.Edge" href="#nfb_studio.scheme.node.edge.Edge">Edge</a></code></h4>
<ul class="two-column">
<li><code><a title="nfb_studio.scheme.node.edge.Edge.adjust" href="#nfb_studio.scheme.node.edge.Edge.adjust">adjust</a></code></li>
<li><code><a title="nfb_studio.scheme.node.edge.Edge.attach" href="#nfb_studio.scheme.node.edge.Edge.attach">attach</a></code></li>
<li><code><a title="nfb_studio.scheme.node.edge.Edge.autoSelect" href="#nfb_studio.scheme.node.edge.Edge.autoSelect">autoSelect</a></code></li>
<li><code><a title="nfb_studio.scheme.node.edge.Edge.boundingRect" href="#nfb_studio.scheme.node.edge.Edge.boundingRect">boundingRect</a></code></li>
<li><code><a title="nfb_studio.scheme.node.edge.Edge.checkDataType" href="#nfb_studio.scheme.node.edge.Edge.checkDataType">checkDataType</a></code></li>
<li><code><a title="nfb_studio.scheme.node.edge.Edge.dataType" href="#nfb_studio.scheme.node.edge.Edge.dataType">dataType</a></code></li>
<li><code><a title="nfb_studio.scheme.node.edge.Edge.detach" href="#nfb_studio.scheme.node.edge.Edge.detach">detach</a></code></li>
<li><code><a title="nfb_studio.scheme.node.edge.Edge.detachAll" href="#nfb_studio.scheme.node.edge.Edge.detachAll">detachAll</a></code></li>
<li><code><a title="nfb_studio.scheme.node.edge.Edge.paint" href="#nfb_studio.scheme.node.edge.Edge.paint">paint</a></code></li>
<li><code><a title="nfb_studio.scheme.node.edge.Edge.paletteChange" href="#nfb_studio.scheme.node.edge.Edge.paletteChange">paletteChange</a></code></li>
<li><code><a title="nfb_studio.scheme.node.edge.Edge.path" href="#nfb_studio.scheme.node.edge.Edge.path">path</a></code></li>
<li><code><a title="nfb_studio.scheme.node.edge.Edge.setSource" href="#nfb_studio.scheme.node.edge.Edge.setSource">setSource</a></code></li>
<li><code><a title="nfb_studio.scheme.node.edge.Edge.setSourcePos" href="#nfb_studio.scheme.node.edge.Edge.setSourcePos">setSourcePos</a></code></li>
<li><code><a title="nfb_studio.scheme.node.edge.Edge.setTarget" href="#nfb_studio.scheme.node.edge.Edge.setTarget">setTarget</a></code></li>
<li><code><a title="nfb_studio.scheme.node.edge.Edge.setTargetPos" href="#nfb_studio.scheme.node.edge.Edge.setTargetPos">setTargetPos</a></code></li>
<li><code><a title="nfb_studio.scheme.node.edge.Edge.shape" href="#nfb_studio.scheme.node.edge.Edge.shape">shape</a></code></li>
<li><code><a title="nfb_studio.scheme.node.edge.Edge.source" href="#nfb_studio.scheme.node.edge.Edge.source">source</a></code></li>
<li><code><a title="nfb_studio.scheme.node.edge.Edge.sourceNode" href="#nfb_studio.scheme.node.edge.Edge.sourceNode">sourceNode</a></code></li>
<li><code><a title="nfb_studio.scheme.node.edge.Edge.sourcePos" href="#nfb_studio.scheme.node.edge.Edge.sourcePos">sourcePos</a></code></li>
<li><code><a title="nfb_studio.scheme.node.edge.Edge.styleChange" href="#nfb_studio.scheme.node.edge.Edge.styleChange">styleChange</a></code></li>
<li><code><a title="nfb_studio.scheme.node.edge.Edge.target" href="#nfb_studio.scheme.node.edge.Edge.target">target</a></code></li>
<li><code><a title="nfb_studio.scheme.node.edge.Edge.targetNode" href="#nfb_studio.scheme.node.edge.Edge.targetNode">targetNode</a></code></li>
<li><code><a title="nfb_studio.scheme.node.edge.Edge.targetPos" href="#nfb_studio.scheme.node.edge.Edge.targetPos">targetPos</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.1</a>.</p>
</footer>
</body>
</html>