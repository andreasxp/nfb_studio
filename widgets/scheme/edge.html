<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.7.4" />
<title>nfb_studio.widgets.scheme.edge API documentation</title>
<meta name="description" content="" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>nfb_studio.widgets.scheme.edge</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from typing import Union

from PySide2.QtCore import Qt, QPointF, QRectF, QLineF
from PySide2.QtGui import QColor, QPainter, QPainterPath, QPen

from nfb_studio.gui import inches_to_pixels as px
from nfb_studio.widgets import RealSizeItem, ShadowSelectableItem

from .node import Node
from .connection import Input, Output


class Edge(RealSizeItem, ShadowSelectableItem):
    &#34;&#34;&#34;An graphics item representing a bezier curve, connecting one node&#39;s output to another&#39;s input.&#34;&#34;&#34;
    # Static graphics properties (in inches)
    outline_thickness = 0.02
    outline_color = Qt.black
    outline_selection_color = QColor.fromRgb(0, 0, 200)

    bezier_max_point_offset = 0.8
    &#34;&#34;&#34;Horizontal offset of control points on a bezier curve compared to its endpoints.&#34;&#34;&#34;
    bezier_close_distance = 1.5
    &#34;&#34;&#34;Distance that&#39;s considered &#34;too close&#34; by the algorithm.

    If distance between source and target is less that this variable, move control points closer together.
    &#34;&#34;&#34;

    def __init__(self):
        super(Edge, self).__init__()
        self.setZValue(-1)  # Draw edges behind nodes

        self._source: Union[Output, None] = None
        &#34;&#34;&#34;An edge is drawn from its source to its target. Node&#39;s output is edge&#39;s source.
        
        This variable represents current source as a variable of type Output.
        &#34;&#34;&#34;
        self._target: Union[Input, None] = None
        &#34;&#34;&#34;An edge is drawn from its source to its target. Node&#39;s input is edge&#39;s target.

        This variable represents current target as a variable of type Input.
        &#34;&#34;&#34;

        self._source_pos: Union[QPointF, None] = None
        &#34;&#34;&#34;An edge is drawn from its source to its target. Node&#39;s output is edge&#39;s source.

        This variable represents current source coordinates in scene pixels.
        &#34;&#34;&#34;
        self._target_pos: Union[QPointF, None] = None
        &#34;&#34;&#34;An edge is drawn from its source to its target. Node&#39;s input is edge&#39;s target.

        This variable represents current target coordinates in scene pixels.
        &#34;&#34;&#34;

        self._pen = QPen(self.outline_color, px(self.outline_thickness))

    def source_node(self) -&gt; Union[Node, None]:
        &#34;&#34;&#34;Return a node from which the edge originates, if it exists.

        If the edge has no source connection, it consequently has no source node.
        &#34;&#34;&#34;
        if self.source():
            return self.source().parentItem()
        return None

    def target_node(self) -&gt; Union[Node, None]:
        &#34;&#34;&#34;Return a node to which the edge goes, if it exists.

        If the edge has no target connection, it consequently has no target node.
        &#34;&#34;&#34;
        if self.target():
            return self.target().parentItem()
        return None

    def source(self) -&gt; Union[Output, None]:
        return self._source

    def target(self) -&gt; Union[Input, None]:
        return self._target

    def setTarget(self, target: Union[Input, None]):
        &#34;&#34;&#34;Set (or unset) the target of this edge.

        Unsetting the target sets the target position to None, which causes the edge to not be drawn, until another
        target (or target position) is supplied.
        &#34;&#34;&#34;
        self._target = target

        if target is None:
            self.prepareGeometryChange()
            self._target_pos = None
        else:
            self.checkDataType()
            self.adjust()

    def setSource(self, source: Union[Output, None]):
        &#34;&#34;&#34;Set (or unset) the source of this edge.

        Unsetting the source sets the source position to None, which causes the edge to not be drawn, until another
        source (or source position) is supplied.
        &#34;&#34;&#34;
        self._source = source

        if source is None:
            self.prepareGeometryChange()
            self._source_pos = None
        else:
            self.checkDataType()
            self.adjust()

    def setTargetPos(self, pos: QPointF):
        &#34;&#34;&#34;Set target position not from a target connection, but to some static coordinates.

        Useful when drawing an edge to the tip of the mouse. This function sets edge&#39;s target to None.
        pos is in scene pixel coordinates.
        &#34;&#34;&#34;
        self._target = None

        self.prepareGeometryChange()
        self._target_pos = pos

    def setSourcePos(self, pos: QPointF):
        &#34;&#34;&#34;Set source position not from a source connection, but to some static coordinates.

        Useful when drawing an edge to the tip of the mouse. This function sets edge&#39;s source to None.
        pos is in scene pixel coordinates.
        &#34;&#34;&#34;
        self._source = None

        self.prepareGeometryChange()
        self._source_pos = pos

    def setPen(self, pen: QPen):
        self._pen = pen

    def pen(self) -&gt; QPen:
        return self._pen

    def adjust(self):
        &#34;&#34;&#34;Adjust the edge&#39;s coordinates to match those of the input and output of nodes.

        Call this function if the node moved or source/target was changed.
        &#34;&#34;&#34;
        if self._source is None or self._target is None:
            return

        self.prepareGeometryChange()

        self._source_pos = self._source.mapToScene(px(self._source.stemTip()))
        self._target_pos = self._target.mapToScene(px(self._target.stemTip()))

    def _bezier_offset(self) -&gt; QPointF:
        &#34;&#34;&#34;Symmetric offset of a control point from source/target.&#34;&#34;&#34;
        closeness_factor = min(
            QLineF(self._source_pos, self._target_pos).length() / px(self.bezier_close_distance),
            1
        )

        return QPointF(px(self.bezier_max_point_offset), 0) * closeness_factor

    def _bezier_point_1(self) -&gt; QPointF:
        &#34;&#34;&#34;Bezier control point 1 for drawing the edge on the screen.&#34;&#34;&#34;
        return self._source_pos + self._bezier_offset()

    def _bezier_point_2(self) -&gt; QPointF:
        &#34;&#34;&#34;Bezier control point 2 for drawing the edge on the screen.&#34;&#34;&#34;
        return self._target_pos - self._bezier_offset()

    def boundingRect(self) -&gt; QRectF:
        if self._source_pos is None or self._target_pos is None:
            return QRectF()

        left = min(self._source_pos.x(), self._bezier_point_2().x())
        right = max(self._target_pos.x(), self._bezier_point_1().x())

        top = min(self._source_pos.y(), self._target_pos.y())
        bottom = max(self._source_pos.y(), self._target_pos.y())

        extra = px(self.outline_thickness)/2

        return QRectF(QPointF(left, top), QPointF(right, bottom)).adjusted(0, -extra, 0, extra)

    def paint(self, painter: QPainter, option, widget=...) -&gt; None:
        if self._source_pos is None or self._target_pos is None:
            return

        painter.setPen(self.pen())

        path = QPainterPath()
        path.moveTo(self._source_pos)
        path.cubicTo(self._bezier_point_1(), self._bezier_point_2(), self._target_pos)
        painter.drawPath(path)

    def itemShadowSelectedHasChangedEvent(self, value):
        if value == True:
            self.setPen(QPen(self.outline_selection_color, px(self.outline_thickness)))
        else:
            self.setPen(QPen(self.outline_color, px(self.outline_thickness)))
        self.update()

    def checkDataType(self):
        &#34;&#34;&#34;Check if the data type of two connections matches and raise a ValueError if it does not.&#34;&#34;&#34;
        if self._source is None or self._target is None:
            return

        if self._source.dataType() != self._target.dataType():
            raise ValueError(
                &#34;edge: data types of connections (\&#34;&#34; +
                str(self._source.dataType()) +
                &#34;\&#34; and \&#34;&#34; +
                str(self._target.dataType()) +
                &#34;\&#34;) are not compatible&#34;
            )

    def updateSelectedStatus(self):
        &#34;&#34;&#34;Checks if both connections at the ends are selected. If so, set this edge to &#34;selected&#34;.

        Edges are not selectable - this function only recolors the edge. Opposite also applies - if at least one of the
        nodes is not selected, deselect this edge. This edge queries nodes - not connections - for selected status.
        Connections derive their selected status from edges, not the other way around.
        &#34;&#34;&#34;
        if self._source is None or self._target is None:
            self.setShadowSelected(False)
            return

        if self.source_node().isSelected() and self.target_node().isSelected():
            self.setShadowSelected(True)
            # Edge does not know which connection called this update. If source called it, target does not know it has
            # to be selected. So the edge explicitly selects both.
            self._source.setShadowSelected(True)
            self._target.setShadowSelected(True)
        else:
            # When deselecting, the connections might still be selected because of other edges - so instead of
            # explicitly deselecting both connections, edge calls updateSelectedStatus() on them.
            # This happens only when the edge was &#34;toggled&#34;, not &#34;set&#34;, to prevent infinite recursion.
            is_toggled = self.isShadowSelected()
            self.setShadowSelected(False)

            if is_toggled:
                self._source.updateSelectedStatus()
                self._target.updateSelectedStatus()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="nfb_studio.widgets.scheme.edge.Edge"><code class="flex name class">
<span>class <span class="ident">Edge</span></span>
</code></dt>
<dd>
<section class="desc"><p>An graphics item representing a bezier curve, connecting one node's output to another's input.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Edge(RealSizeItem, ShadowSelectableItem):
    &#34;&#34;&#34;An graphics item representing a bezier curve, connecting one node&#39;s output to another&#39;s input.&#34;&#34;&#34;
    # Static graphics properties (in inches)
    outline_thickness = 0.02
    outline_color = Qt.black
    outline_selection_color = QColor.fromRgb(0, 0, 200)

    bezier_max_point_offset = 0.8
    &#34;&#34;&#34;Horizontal offset of control points on a bezier curve compared to its endpoints.&#34;&#34;&#34;
    bezier_close_distance = 1.5
    &#34;&#34;&#34;Distance that&#39;s considered &#34;too close&#34; by the algorithm.

    If distance between source and target is less that this variable, move control points closer together.
    &#34;&#34;&#34;

    def __init__(self):
        super(Edge, self).__init__()
        self.setZValue(-1)  # Draw edges behind nodes

        self._source: Union[Output, None] = None
        &#34;&#34;&#34;An edge is drawn from its source to its target. Node&#39;s output is edge&#39;s source.
        
        This variable represents current source as a variable of type Output.
        &#34;&#34;&#34;
        self._target: Union[Input, None] = None
        &#34;&#34;&#34;An edge is drawn from its source to its target. Node&#39;s input is edge&#39;s target.

        This variable represents current target as a variable of type Input.
        &#34;&#34;&#34;

        self._source_pos: Union[QPointF, None] = None
        &#34;&#34;&#34;An edge is drawn from its source to its target. Node&#39;s output is edge&#39;s source.

        This variable represents current source coordinates in scene pixels.
        &#34;&#34;&#34;
        self._target_pos: Union[QPointF, None] = None
        &#34;&#34;&#34;An edge is drawn from its source to its target. Node&#39;s input is edge&#39;s target.

        This variable represents current target coordinates in scene pixels.
        &#34;&#34;&#34;

        self._pen = QPen(self.outline_color, px(self.outline_thickness))

    def source_node(self) -&gt; Union[Node, None]:
        &#34;&#34;&#34;Return a node from which the edge originates, if it exists.

        If the edge has no source connection, it consequently has no source node.
        &#34;&#34;&#34;
        if self.source():
            return self.source().parentItem()
        return None

    def target_node(self) -&gt; Union[Node, None]:
        &#34;&#34;&#34;Return a node to which the edge goes, if it exists.

        If the edge has no target connection, it consequently has no target node.
        &#34;&#34;&#34;
        if self.target():
            return self.target().parentItem()
        return None

    def source(self) -&gt; Union[Output, None]:
        return self._source

    def target(self) -&gt; Union[Input, None]:
        return self._target

    def setTarget(self, target: Union[Input, None]):
        &#34;&#34;&#34;Set (or unset) the target of this edge.

        Unsetting the target sets the target position to None, which causes the edge to not be drawn, until another
        target (or target position) is supplied.
        &#34;&#34;&#34;
        self._target = target

        if target is None:
            self.prepareGeometryChange()
            self._target_pos = None
        else:
            self.checkDataType()
            self.adjust()

    def setSource(self, source: Union[Output, None]):
        &#34;&#34;&#34;Set (or unset) the source of this edge.

        Unsetting the source sets the source position to None, which causes the edge to not be drawn, until another
        source (or source position) is supplied.
        &#34;&#34;&#34;
        self._source = source

        if source is None:
            self.prepareGeometryChange()
            self._source_pos = None
        else:
            self.checkDataType()
            self.adjust()

    def setTargetPos(self, pos: QPointF):
        &#34;&#34;&#34;Set target position not from a target connection, but to some static coordinates.

        Useful when drawing an edge to the tip of the mouse. This function sets edge&#39;s target to None.
        pos is in scene pixel coordinates.
        &#34;&#34;&#34;
        self._target = None

        self.prepareGeometryChange()
        self._target_pos = pos

    def setSourcePos(self, pos: QPointF):
        &#34;&#34;&#34;Set source position not from a source connection, but to some static coordinates.

        Useful when drawing an edge to the tip of the mouse. This function sets edge&#39;s source to None.
        pos is in scene pixel coordinates.
        &#34;&#34;&#34;
        self._source = None

        self.prepareGeometryChange()
        self._source_pos = pos

    def setPen(self, pen: QPen):
        self._pen = pen

    def pen(self) -&gt; QPen:
        return self._pen

    def adjust(self):
        &#34;&#34;&#34;Adjust the edge&#39;s coordinates to match those of the input and output of nodes.

        Call this function if the node moved or source/target was changed.
        &#34;&#34;&#34;
        if self._source is None or self._target is None:
            return

        self.prepareGeometryChange()

        self._source_pos = self._source.mapToScene(px(self._source.stemTip()))
        self._target_pos = self._target.mapToScene(px(self._target.stemTip()))

    def _bezier_offset(self) -&gt; QPointF:
        &#34;&#34;&#34;Symmetric offset of a control point from source/target.&#34;&#34;&#34;
        closeness_factor = min(
            QLineF(self._source_pos, self._target_pos).length() / px(self.bezier_close_distance),
            1
        )

        return QPointF(px(self.bezier_max_point_offset), 0) * closeness_factor

    def _bezier_point_1(self) -&gt; QPointF:
        &#34;&#34;&#34;Bezier control point 1 for drawing the edge on the screen.&#34;&#34;&#34;
        return self._source_pos + self._bezier_offset()

    def _bezier_point_2(self) -&gt; QPointF:
        &#34;&#34;&#34;Bezier control point 2 for drawing the edge on the screen.&#34;&#34;&#34;
        return self._target_pos - self._bezier_offset()

    def boundingRect(self) -&gt; QRectF:
        if self._source_pos is None or self._target_pos is None:
            return QRectF()

        left = min(self._source_pos.x(), self._bezier_point_2().x())
        right = max(self._target_pos.x(), self._bezier_point_1().x())

        top = min(self._source_pos.y(), self._target_pos.y())
        bottom = max(self._source_pos.y(), self._target_pos.y())

        extra = px(self.outline_thickness)/2

        return QRectF(QPointF(left, top), QPointF(right, bottom)).adjusted(0, -extra, 0, extra)

    def paint(self, painter: QPainter, option, widget=...) -&gt; None:
        if self._source_pos is None or self._target_pos is None:
            return

        painter.setPen(self.pen())

        path = QPainterPath()
        path.moveTo(self._source_pos)
        path.cubicTo(self._bezier_point_1(), self._bezier_point_2(), self._target_pos)
        painter.drawPath(path)

    def itemShadowSelectedHasChangedEvent(self, value):
        if value == True:
            self.setPen(QPen(self.outline_selection_color, px(self.outline_thickness)))
        else:
            self.setPen(QPen(self.outline_color, px(self.outline_thickness)))
        self.update()

    def checkDataType(self):
        &#34;&#34;&#34;Check if the data type of two connections matches and raise a ValueError if it does not.&#34;&#34;&#34;
        if self._source is None or self._target is None:
            return

        if self._source.dataType() != self._target.dataType():
            raise ValueError(
                &#34;edge: data types of connections (\&#34;&#34; +
                str(self._source.dataType()) +
                &#34;\&#34; and \&#34;&#34; +
                str(self._target.dataType()) +
                &#34;\&#34;) are not compatible&#34;
            )

    def updateSelectedStatus(self):
        &#34;&#34;&#34;Checks if both connections at the ends are selected. If so, set this edge to &#34;selected&#34;.

        Edges are not selectable - this function only recolors the edge. Opposite also applies - if at least one of the
        nodes is not selected, deselect this edge. This edge queries nodes - not connections - for selected status.
        Connections derive their selected status from edges, not the other way around.
        &#34;&#34;&#34;
        if self._source is None or self._target is None:
            self.setShadowSelected(False)
            return

        if self.source_node().isSelected() and self.target_node().isSelected():
            self.setShadowSelected(True)
            # Edge does not know which connection called this update. If source called it, target does not know it has
            # to be selected. So the edge explicitly selects both.
            self._source.setShadowSelected(True)
            self._target.setShadowSelected(True)
        else:
            # When deselecting, the connections might still be selected because of other edges - so instead of
            # explicitly deselecting both connections, edge calls updateSelectedStatus() on them.
            # This happens only when the edge was &#34;toggled&#34;, not &#34;set&#34;, to prevent infinite recursion.
            is_toggled = self.isShadowSelected()
            self.setShadowSelected(False)

            if is_toggled:
                self._source.updateSelectedStatus()
                self._target.updateSelectedStatus()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="nfb_studio.widgets.real_size_item.RealSizeItem" href="../real_size_item.html#nfb_studio.widgets.real_size_item.RealSizeItem">RealSizeItem</a></li>
<li><a title="nfb_studio.widgets.shadow_selectable_item.ShadowSelectableItem" href="../shadow_selectable_item.html#nfb_studio.widgets.shadow_selectable_item.ShadowSelectableItem">ShadowSelectableItem</a></li>
<li>PySide2.QtWidgets.QGraphicsItem</li>
<li>Shiboken.Object</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="nfb_studio.widgets.scheme.edge.Edge.bezier_close_distance"><code class="name">var <span class="ident">bezier_close_distance</span></code></dt>
<dd>
<section class="desc"><p>Distance that's considered "too close" by the algorithm.</p>
<p>If distance between source and target is less that this variable, move control points closer together.</p></section>
</dd>
<dt id="nfb_studio.widgets.scheme.edge.Edge.bezier_max_point_offset"><code class="name">var <span class="ident">bezier_max_point_offset</span></code></dt>
<dd>
<section class="desc"><p>Horizontal offset of control points on a bezier curve compared to its endpoints.</p></section>
</dd>
<dt id="nfb_studio.widgets.scheme.edge.Edge.outline_color"><code class="name">var <span class="ident">outline_color</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="nfb_studio.widgets.scheme.edge.Edge.outline_selection_color"><code class="name">var <span class="ident">outline_selection_color</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="nfb_studio.widgets.scheme.edge.Edge.outline_thickness"><code class="name">var <span class="ident">outline_thickness</span></code></dt>
<dd>
<section class="desc"><p>Convert a string or number to a floating point number, if possible.</p></section>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="nfb_studio.widgets.scheme.edge.Edge.adjust"><code class="name flex">
<span>def <span class="ident">adjust</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Adjust the edge's coordinates to match those of the input and output of nodes.</p>
<p>Call this function if the node moved or source/target was changed.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def adjust(self):
    &#34;&#34;&#34;Adjust the edge&#39;s coordinates to match those of the input and output of nodes.

    Call this function if the node moved or source/target was changed.
    &#34;&#34;&#34;
    if self._source is None or self._target is None:
        return

    self.prepareGeometryChange()

    self._source_pos = self._source.mapToScene(px(self._source.stemTip()))
    self._target_pos = self._target.mapToScene(px(self._target.stemTip()))</code></pre>
</details>
</dd>
<dt id="nfb_studio.widgets.scheme.edge.Edge.boundingRect"><code class="name flex">
<span>def <span class="ident">boundingRect</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>boundingRect(self) -&gt; PySide2.QtCore.QRectF</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def boundingRect(self) -&gt; QRectF:
    if self._source_pos is None or self._target_pos is None:
        return QRectF()

    left = min(self._source_pos.x(), self._bezier_point_2().x())
    right = max(self._target_pos.x(), self._bezier_point_1().x())

    top = min(self._source_pos.y(), self._target_pos.y())
    bottom = max(self._source_pos.y(), self._target_pos.y())

    extra = px(self.outline_thickness)/2

    return QRectF(QPointF(left, top), QPointF(right, bottom)).adjusted(0, -extra, 0, extra)</code></pre>
</details>
</dd>
<dt id="nfb_studio.widgets.scheme.edge.Edge.checkDataType"><code class="name flex">
<span>def <span class="ident">checkDataType</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Check if the data type of two connections matches and raise a ValueError if it does not.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def checkDataType(self):
    &#34;&#34;&#34;Check if the data type of two connections matches and raise a ValueError if it does not.&#34;&#34;&#34;
    if self._source is None or self._target is None:
        return

    if self._source.dataType() != self._target.dataType():
        raise ValueError(
            &#34;edge: data types of connections (\&#34;&#34; +
            str(self._source.dataType()) +
            &#34;\&#34; and \&#34;&#34; +
            str(self._target.dataType()) +
            &#34;\&#34;) are not compatible&#34;
        )</code></pre>
</details>
</dd>
<dt id="nfb_studio.widgets.scheme.edge.Edge.paint"><code class="name flex">
<span>def <span class="ident">paint</span></span>(<span>self, painter, option, widget=Ellipsis)</span>
</code></dt>
<dd>
<section class="desc"><p>paint(self, painter: PySide2.QtGui.QPainter, option: PySide2.QtWidgets.QStyleOptionGraphicsItem, widget: typing.Union[PySide2.QtWidgets.QWidget, NoneType] = None)</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def paint(self, painter: QPainter, option, widget=...) -&gt; None:
    if self._source_pos is None or self._target_pos is None:
        return

    painter.setPen(self.pen())

    path = QPainterPath()
    path.moveTo(self._source_pos)
    path.cubicTo(self._bezier_point_1(), self._bezier_point_2(), self._target_pos)
    painter.drawPath(path)</code></pre>
</details>
</dd>
<dt id="nfb_studio.widgets.scheme.edge.Edge.pen"><code class="name flex">
<span>def <span class="ident">pen</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pen(self) -&gt; QPen:
    return self._pen</code></pre>
</details>
</dd>
<dt id="nfb_studio.widgets.scheme.edge.Edge.setPen"><code class="name flex">
<span>def <span class="ident">setPen</span></span>(<span>self, pen)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setPen(self, pen: QPen):
    self._pen = pen</code></pre>
</details>
</dd>
<dt id="nfb_studio.widgets.scheme.edge.Edge.setSource"><code class="name flex">
<span>def <span class="ident">setSource</span></span>(<span>self, source)</span>
</code></dt>
<dd>
<section class="desc"><p>Set (or unset) the source of this edge.</p>
<p>Unsetting the source sets the source position to None, which causes the edge to not be drawn, until another
source (or source position) is supplied.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setSource(self, source: Union[Output, None]):
    &#34;&#34;&#34;Set (or unset) the source of this edge.

    Unsetting the source sets the source position to None, which causes the edge to not be drawn, until another
    source (or source position) is supplied.
    &#34;&#34;&#34;
    self._source = source

    if source is None:
        self.prepareGeometryChange()
        self._source_pos = None
    else:
        self.checkDataType()
        self.adjust()</code></pre>
</details>
</dd>
<dt id="nfb_studio.widgets.scheme.edge.Edge.setSourcePos"><code class="name flex">
<span>def <span class="ident">setSourcePos</span></span>(<span>self, pos)</span>
</code></dt>
<dd>
<section class="desc"><p>Set source position not from a source connection, but to some static coordinates.</p>
<p>Useful when drawing an edge to the tip of the mouse. This function sets edge's source to None.
pos is in scene pixel coordinates.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setSourcePos(self, pos: QPointF):
    &#34;&#34;&#34;Set source position not from a source connection, but to some static coordinates.

    Useful when drawing an edge to the tip of the mouse. This function sets edge&#39;s source to None.
    pos is in scene pixel coordinates.
    &#34;&#34;&#34;
    self._source = None

    self.prepareGeometryChange()
    self._source_pos = pos</code></pre>
</details>
</dd>
<dt id="nfb_studio.widgets.scheme.edge.Edge.setTarget"><code class="name flex">
<span>def <span class="ident">setTarget</span></span>(<span>self, target)</span>
</code></dt>
<dd>
<section class="desc"><p>Set (or unset) the target of this edge.</p>
<p>Unsetting the target sets the target position to None, which causes the edge to not be drawn, until another
target (or target position) is supplied.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setTarget(self, target: Union[Input, None]):
    &#34;&#34;&#34;Set (or unset) the target of this edge.

    Unsetting the target sets the target position to None, which causes the edge to not be drawn, until another
    target (or target position) is supplied.
    &#34;&#34;&#34;
    self._target = target

    if target is None:
        self.prepareGeometryChange()
        self._target_pos = None
    else:
        self.checkDataType()
        self.adjust()</code></pre>
</details>
</dd>
<dt id="nfb_studio.widgets.scheme.edge.Edge.setTargetPos"><code class="name flex">
<span>def <span class="ident">setTargetPos</span></span>(<span>self, pos)</span>
</code></dt>
<dd>
<section class="desc"><p>Set target position not from a target connection, but to some static coordinates.</p>
<p>Useful when drawing an edge to the tip of the mouse. This function sets edge's target to None.
pos is in scene pixel coordinates.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setTargetPos(self, pos: QPointF):
    &#34;&#34;&#34;Set target position not from a target connection, but to some static coordinates.

    Useful when drawing an edge to the tip of the mouse. This function sets edge&#39;s target to None.
    pos is in scene pixel coordinates.
    &#34;&#34;&#34;
    self._target = None

    self.prepareGeometryChange()
    self._target_pos = pos</code></pre>
</details>
</dd>
<dt id="nfb_studio.widgets.scheme.edge.Edge.source"><code class="name flex">
<span>def <span class="ident">source</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def source(self) -&gt; Union[Output, None]:
    return self._source</code></pre>
</details>
</dd>
<dt id="nfb_studio.widgets.scheme.edge.Edge.source_node"><code class="name flex">
<span>def <span class="ident">source_node</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Return a node from which the edge originates, if it exists.</p>
<p>If the edge has no source connection, it consequently has no source node.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def source_node(self) -&gt; Union[Node, None]:
    &#34;&#34;&#34;Return a node from which the edge originates, if it exists.

    If the edge has no source connection, it consequently has no source node.
    &#34;&#34;&#34;
    if self.source():
        return self.source().parentItem()
    return None</code></pre>
</details>
</dd>
<dt id="nfb_studio.widgets.scheme.edge.Edge.target"><code class="name flex">
<span>def <span class="ident">target</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def target(self) -&gt; Union[Input, None]:
    return self._target</code></pre>
</details>
</dd>
<dt id="nfb_studio.widgets.scheme.edge.Edge.target_node"><code class="name flex">
<span>def <span class="ident">target_node</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Return a node to which the edge goes, if it exists.</p>
<p>If the edge has no target connection, it consequently has no target node.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def target_node(self) -&gt; Union[Node, None]:
    &#34;&#34;&#34;Return a node to which the edge goes, if it exists.

    If the edge has no target connection, it consequently has no target node.
    &#34;&#34;&#34;
    if self.target():
        return self.target().parentItem()
    return None</code></pre>
</details>
</dd>
<dt id="nfb_studio.widgets.scheme.edge.Edge.updateSelectedStatus"><code class="name flex">
<span>def <span class="ident">updateSelectedStatus</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Checks if both connections at the ends are selected. If so, set this edge to "selected".</p>
<p>Edges are not selectable - this function only recolors the edge. Opposite also applies - if at least one of the
nodes is not selected, deselect this edge. This edge queries nodes - not connections - for selected status.
Connections derive their selected status from edges, not the other way around.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def updateSelectedStatus(self):
    &#34;&#34;&#34;Checks if both connections at the ends are selected. If so, set this edge to &#34;selected&#34;.

    Edges are not selectable - this function only recolors the edge. Opposite also applies - if at least one of the
    nodes is not selected, deselect this edge. This edge queries nodes - not connections - for selected status.
    Connections derive their selected status from edges, not the other way around.
    &#34;&#34;&#34;
    if self._source is None or self._target is None:
        self.setShadowSelected(False)
        return

    if self.source_node().isSelected() and self.target_node().isSelected():
        self.setShadowSelected(True)
        # Edge does not know which connection called this update. If source called it, target does not know it has
        # to be selected. So the edge explicitly selects both.
        self._source.setShadowSelected(True)
        self._target.setShadowSelected(True)
    else:
        # When deselecting, the connections might still be selected because of other edges - so instead of
        # explicitly deselecting both connections, edge calls updateSelectedStatus() on them.
        # This happens only when the edge was &#34;toggled&#34;, not &#34;set&#34;, to prevent infinite recursion.
        is_toggled = self.isShadowSelected()
        self.setShadowSelected(False)

        if is_toggled:
            self._source.updateSelectedStatus()
            self._target.updateSelectedStatus()</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="nfb_studio.widgets.real_size_item.RealSizeItem" href="../real_size_item.html#nfb_studio.widgets.real_size_item.RealSizeItem">RealSizeItem</a></b></code>:
<ul class="hlist">
<li><code><a title="nfb_studio.widgets.real_size_item.RealSizeItem.position" href="../real_size_item.html#nfb_studio.widgets.real_size_item.RealSizeItem.position">position</a></code></li>
<li><code><a title="nfb_studio.widgets.real_size_item.RealSizeItem.setPosition" href="../real_size_item.html#nfb_studio.widgets.real_size_item.RealSizeItem.setPosition">setPosition</a></code></li>
</ul>
</li>
<li><code><b><a title="nfb_studio.widgets.shadow_selectable_item.ShadowSelectableItem" href="../shadow_selectable_item.html#nfb_studio.widgets.shadow_selectable_item.ShadowSelectableItem">ShadowSelectableItem</a></b></code>:
<ul class="hlist">
<li><code><a title="nfb_studio.widgets.shadow_selectable_item.ShadowSelectableItem.itemShadowSelectedHasChangedEvent" href="../shadow_selectable_item.html#nfb_studio.widgets.shadow_selectable_item.ShadowSelectableItem.itemShadowSelectedHasChangedEvent">itemShadowSelectedHasChangedEvent</a></code></li>
</ul>
</li>
<li><code><b><a title="nfb_studio.widgets.shadow_selectable_item.ShadowSelectableItem" href="../shadow_selectable_item.html#nfb_studio.widgets.shadow_selectable_item.ShadowSelectableItem">ShadowSelectableItem</a></b></code>:
<ul class="hlist">
<li><code><a title="nfb_studio.widgets.shadow_selectable_item.ShadowSelectableItem.itemShadowSelectedChangeEvent" href="../shadow_selectable_item.html#nfb_studio.widgets.shadow_selectable_item.ShadowSelectableItem.itemShadowSelectedChangeEvent">itemShadowSelectedChangeEvent</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="nfb_studio.widgets.scheme" href="index.html">nfb_studio.widgets.scheme</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="nfb_studio.widgets.scheme.edge.Edge" href="#nfb_studio.widgets.scheme.edge.Edge">Edge</a></code></h4>
<ul class="">
<li><code><a title="nfb_studio.widgets.scheme.edge.Edge.adjust" href="#nfb_studio.widgets.scheme.edge.Edge.adjust">adjust</a></code></li>
<li><code><a title="nfb_studio.widgets.scheme.edge.Edge.bezier_close_distance" href="#nfb_studio.widgets.scheme.edge.Edge.bezier_close_distance">bezier_close_distance</a></code></li>
<li><code><a title="nfb_studio.widgets.scheme.edge.Edge.bezier_max_point_offset" href="#nfb_studio.widgets.scheme.edge.Edge.bezier_max_point_offset">bezier_max_point_offset</a></code></li>
<li><code><a title="nfb_studio.widgets.scheme.edge.Edge.boundingRect" href="#nfb_studio.widgets.scheme.edge.Edge.boundingRect">boundingRect</a></code></li>
<li><code><a title="nfb_studio.widgets.scheme.edge.Edge.checkDataType" href="#nfb_studio.widgets.scheme.edge.Edge.checkDataType">checkDataType</a></code></li>
<li><code><a title="nfb_studio.widgets.scheme.edge.Edge.outline_color" href="#nfb_studio.widgets.scheme.edge.Edge.outline_color">outline_color</a></code></li>
<li><code><a title="nfb_studio.widgets.scheme.edge.Edge.outline_selection_color" href="#nfb_studio.widgets.scheme.edge.Edge.outline_selection_color">outline_selection_color</a></code></li>
<li><code><a title="nfb_studio.widgets.scheme.edge.Edge.outline_thickness" href="#nfb_studio.widgets.scheme.edge.Edge.outline_thickness">outline_thickness</a></code></li>
<li><code><a title="nfb_studio.widgets.scheme.edge.Edge.paint" href="#nfb_studio.widgets.scheme.edge.Edge.paint">paint</a></code></li>
<li><code><a title="nfb_studio.widgets.scheme.edge.Edge.pen" href="#nfb_studio.widgets.scheme.edge.Edge.pen">pen</a></code></li>
<li><code><a title="nfb_studio.widgets.scheme.edge.Edge.setPen" href="#nfb_studio.widgets.scheme.edge.Edge.setPen">setPen</a></code></li>
<li><code><a title="nfb_studio.widgets.scheme.edge.Edge.setSource" href="#nfb_studio.widgets.scheme.edge.Edge.setSource">setSource</a></code></li>
<li><code><a title="nfb_studio.widgets.scheme.edge.Edge.setSourcePos" href="#nfb_studio.widgets.scheme.edge.Edge.setSourcePos">setSourcePos</a></code></li>
<li><code><a title="nfb_studio.widgets.scheme.edge.Edge.setTarget" href="#nfb_studio.widgets.scheme.edge.Edge.setTarget">setTarget</a></code></li>
<li><code><a title="nfb_studio.widgets.scheme.edge.Edge.setTargetPos" href="#nfb_studio.widgets.scheme.edge.Edge.setTargetPos">setTargetPos</a></code></li>
<li><code><a title="nfb_studio.widgets.scheme.edge.Edge.source" href="#nfb_studio.widgets.scheme.edge.Edge.source">source</a></code></li>
<li><code><a title="nfb_studio.widgets.scheme.edge.Edge.source_node" href="#nfb_studio.widgets.scheme.edge.Edge.source_node">source_node</a></code></li>
<li><code><a title="nfb_studio.widgets.scheme.edge.Edge.target" href="#nfb_studio.widgets.scheme.edge.Edge.target">target</a></code></li>
<li><code><a title="nfb_studio.widgets.scheme.edge.Edge.target_node" href="#nfb_studio.widgets.scheme.edge.Edge.target_node">target_node</a></code></li>
<li><code><a title="nfb_studio.widgets.scheme.edge.Edge.updateSelectedStatus" href="#nfb_studio.widgets.scheme.edge.Edge.updateSelectedStatus">updateSelectedStatus</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.7.4</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>