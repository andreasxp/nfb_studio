<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.3" />
<title>nfb_studio.widgets.scheme.graph API documentation</title>
<meta name="description" content="Classes representing the graph stucture in the node scheme." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/highlight.min.js" integrity="sha256-eOgo0OtLL4cdq7RdwRUiGKLX9XsIJ7nGhWEKbohmVAQ=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>nfb_studio.widgets.scheme.graph</code></h1>
</header>
<section id="section-intro">
<p>Classes representing the graph stucture in the node scheme.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;Classes representing the graph stucture in the node scheme.&#34;&#34;&#34;
from typing import Union
from itertools import filterfalse
from collections import MutableSet

from PySide2.QtCore import QRectF

from .graphics_item_group import GraphicsItemGroup
from .node import Node, Edge, Input, Output

class Graph(GraphicsItemGroup):
    &#34;&#34;&#34;A collection of nodes and edges connecting them.&#34;&#34;&#34;
    def __init__(self):
        super().__init__()

        self.nodes = set()
        self.edges = set()

    # Core set methods =================================================================================================
    def add(self, item):
        if isinstance(item, Node):
            self.nodes.add(item)
        elif isinstance(item, Edge):
            self.edges.add(item)
        else:
            raise TypeError(&#34;Graph accepts only Node and Edge objects, not &#34; + type(item).__name__)

        super().add(item)
    
    def discard(self, item):
        super().discard(item)
        
        if isinstance(item, Node):
            # If a node is removed, all edges to or from that node are also removed.
            # Remove connected edges
            to_remove = []
            for edge in self.edges:
                if edge.sourceNode() == item or edge.targetNode() == item:
                    to_remove.append(edge)
            
            for edge in to_remove:
                self.discard(edge)

            # Remove the node
            self.nodes.discard(item)
        elif isinstance(item, Edge):
            # Disconnect from nodes that are still in this graph
            item.detachAll()
            self.edges.discard(item)
    
    # Edge manipulation ================================================================================================
    def connect_nodes(self, source: Output, target: Input) -&gt; Edge:
        &#34;&#34;&#34;Connect an Output connection to an Input connection with an edge.
        
        Returns the newly created edge.
        &#34;&#34;&#34;
        edge = Edge()
        edge.setSource(source)
        edge.setTarget(target)

        self.add(edge)
        return edge

    def disconnect_nodes(self, source: Output, target: Input) -&gt; Union[Edge, None]:
        &#34;&#34;&#34;Remove a connection between a node output and an input.
        
        If output and input are connected more than once, only one edge is removed.
        Returns the edge that was removed, or None if no such edge was found.
        &#34;&#34;&#34;
        for edge in self.edges:
            if edge.source() == source and edge.target() == target:
                self.discard(edge)
                return edge
        return None

    # Selection ========================================================================================================
    def selectAll(self):
        &#34;&#34;&#34;Select the whole graph.&#34;&#34;&#34;
        for node in self.nodes:
            node.setSelected(True)

    def selection(self):
        &#34;&#34;&#34;Return a Graph containing all selected nodes and edges.
        
        This selection is equivalent to the highlighted items the user sees on screen. This means that it is possible
        that the resulting graph will contain only edges and no nodes.
        &#34;&#34;&#34;
        result = Graph()

        for item in self:
            if item.isSelected():
                result.add(item)

        return result
    
    def clipboardSelection(self):
        &#34;&#34;&#34;Return a Graph containing all selected nodes and edges, suitable for copying to clipboard.
        
        This selection is similar to `self.selection()` in that it only contains nodes and edges highlighted to the
        user. The difference is that if the user selected only edges, this is considered unsuitable for copying and an
        empty graph is returned instead.
        &#34;&#34;&#34;
        result = self.selection()

        if len(result.nodes) == 0:
            return Graph()

        return result

    def wideSelection(self):
        &#34;&#34;&#34;Return a graph snapshot containing all selected nodes and all connected edges.
        
        Unlike `self.selection()`, this method also gets all edges where at least one end is a selected node.  
        This snapshot is equivalent to the items that are deleted when a selection is removed or cut.
        &#34;&#34;&#34;
        result = self.selection()

        for edge in self.edges:
            if ((edge.sourceNode() is not None and self.sourceNode().isSelected()) or 
                (edge.targetNode() is not None and self.targetNode().isSelected())):
                result.add(edge)  

        return result
    
    def extract(self, other):
        &#34;&#34;&#34;Extract other graph from this graph.
        
        After calling this function, self.isdisjoint(other) will return True. All edges that become dangling from node
        removal are also removed.
        &#34;&#34;&#34;
        for edge in other.edges:
            self.discard(edge)

        for node in other.nodes:
            self.discard(node)

    def merge(self, other):
        &#34;&#34;&#34;Merge other graph into this graph.
        
        After calling this function, other.issubset(self) will return True.
        &#34;&#34;&#34;
        super().__ior__(other)
        self.nodes |= other.nodes
        self.edges |= other.edges

    # Serialization ====================================================================================================
    def serialize(self) -&gt; dict:
        data = {}

        # Serialize nodes ----------------------------------------------------------------------------------------------
        nodes = list(self.nodes)
        data[&#34;nodes&#34;] = nodes

        # Serialize edges ----------------------------------------------------------------------------------------------
        data[&#34;edges&#34;] = []

        for edge in self.edges:
            source_node = edge.sourceNode()
            target_node = edge.targetNode()

            if source_node is None or target_node is None:
                # Not serializing dangling nodes
                continue

            edge_data = {
                &#34;source&#34;: {
                    &#34;node_index&#34;: nodes.index(source_node),
                    &#34;connection_index&#34;: source_node.outputs.index(edge.source())
                },
                &#34;target&#34;: {
                    &#34;node_index&#34;: nodes.index(target_node),
                    &#34;connection_index&#34;: target_node.inputs.index(edge.target())
                }
            }

            data[&#34;edges&#34;].append(edge_data)

        return data
    
    def deserialize(self, data: dict):
        &#34;&#34;&#34;Deserialize this object from a dict of data.
        
        Edges are not serialized as objects. Instead, only their connections are remembered and reconstructed during the
        deserialization.
        &#34;&#34;&#34;
        self.clear()

        # Deserialize nodes --------------------------------------------------------------------------------------------
        for node in data[&#34;nodes&#34;]:
            self.add(node)

        # Deserialize edges --------------------------------------------------------------------------------------------
        for edge_data in data[&#34;edges&#34;]:
            source_node = data[&#34;nodes&#34;][edge_data[&#34;source&#34;][&#34;node_index&#34;]]
            target_node = data[&#34;nodes&#34;][edge_data[&#34;target&#34;][&#34;node_index&#34;]]

            source = source_node.outputs[edge_data[&#34;source&#34;][&#34;connection_index&#34;]]
            target = target_node.inputs[edge_data[&#34;target&#34;][&#34;connection_index&#34;]]

            self.connect_nodes(source, target)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="nfb_studio.widgets.scheme.graph.Graph"><code class="flex name class">
<span>class <span class="ident">Graph</span></span>
</code></dt>
<dd>
<div class="desc"><p>A collection of nodes and edges connecting them.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Graph(GraphicsItemGroup):
    &#34;&#34;&#34;A collection of nodes and edges connecting them.&#34;&#34;&#34;
    def __init__(self):
        super().__init__()

        self.nodes = set()
        self.edges = set()

    # Core set methods =================================================================================================
    def add(self, item):
        if isinstance(item, Node):
            self.nodes.add(item)
        elif isinstance(item, Edge):
            self.edges.add(item)
        else:
            raise TypeError(&#34;Graph accepts only Node and Edge objects, not &#34; + type(item).__name__)

        super().add(item)
    
    def discard(self, item):
        super().discard(item)
        
        if isinstance(item, Node):
            # If a node is removed, all edges to or from that node are also removed.
            # Remove connected edges
            to_remove = []
            for edge in self.edges:
                if edge.sourceNode() == item or edge.targetNode() == item:
                    to_remove.append(edge)
            
            for edge in to_remove:
                self.discard(edge)

            # Remove the node
            self.nodes.discard(item)
        elif isinstance(item, Edge):
            # Disconnect from nodes that are still in this graph
            item.detachAll()
            self.edges.discard(item)
    
    # Edge manipulation ================================================================================================
    def connect_nodes(self, source: Output, target: Input) -&gt; Edge:
        &#34;&#34;&#34;Connect an Output connection to an Input connection with an edge.
        
        Returns the newly created edge.
        &#34;&#34;&#34;
        edge = Edge()
        edge.setSource(source)
        edge.setTarget(target)

        self.add(edge)
        return edge

    def disconnect_nodes(self, source: Output, target: Input) -&gt; Union[Edge, None]:
        &#34;&#34;&#34;Remove a connection between a node output and an input.
        
        If output and input are connected more than once, only one edge is removed.
        Returns the edge that was removed, or None if no such edge was found.
        &#34;&#34;&#34;
        for edge in self.edges:
            if edge.source() == source and edge.target() == target:
                self.discard(edge)
                return edge
        return None

    # Selection ========================================================================================================
    def selectAll(self):
        &#34;&#34;&#34;Select the whole graph.&#34;&#34;&#34;
        for node in self.nodes:
            node.setSelected(True)

    def selection(self):
        &#34;&#34;&#34;Return a Graph containing all selected nodes and edges.
        
        This selection is equivalent to the highlighted items the user sees on screen. This means that it is possible
        that the resulting graph will contain only edges and no nodes.
        &#34;&#34;&#34;
        result = Graph()

        for item in self:
            if item.isSelected():
                result.add(item)

        return result
    
    def clipboardSelection(self):
        &#34;&#34;&#34;Return a Graph containing all selected nodes and edges, suitable for copying to clipboard.
        
        This selection is similar to `self.selection()` in that it only contains nodes and edges highlighted to the
        user. The difference is that if the user selected only edges, this is considered unsuitable for copying and an
        empty graph is returned instead.
        &#34;&#34;&#34;
        result = self.selection()

        if len(result.nodes) == 0:
            return Graph()

        return result

    def wideSelection(self):
        &#34;&#34;&#34;Return a graph snapshot containing all selected nodes and all connected edges.
        
        Unlike `self.selection()`, this method also gets all edges where at least one end is a selected node.  
        This snapshot is equivalent to the items that are deleted when a selection is removed or cut.
        &#34;&#34;&#34;
        result = self.selection()

        for edge in self.edges:
            if ((edge.sourceNode() is not None and self.sourceNode().isSelected()) or 
                (edge.targetNode() is not None and self.targetNode().isSelected())):
                result.add(edge)  

        return result
    
    def extract(self, other):
        &#34;&#34;&#34;Extract other graph from this graph.
        
        After calling this function, self.isdisjoint(other) will return True. All edges that become dangling from node
        removal are also removed.
        &#34;&#34;&#34;
        for edge in other.edges:
            self.discard(edge)

        for node in other.nodes:
            self.discard(node)

    def merge(self, other):
        &#34;&#34;&#34;Merge other graph into this graph.
        
        After calling this function, other.issubset(self) will return True.
        &#34;&#34;&#34;
        super().__ior__(other)
        self.nodes |= other.nodes
        self.edges |= other.edges

    # Serialization ====================================================================================================
    def serialize(self) -&gt; dict:
        data = {}

        # Serialize nodes ----------------------------------------------------------------------------------------------
        nodes = list(self.nodes)
        data[&#34;nodes&#34;] = nodes

        # Serialize edges ----------------------------------------------------------------------------------------------
        data[&#34;edges&#34;] = []

        for edge in self.edges:
            source_node = edge.sourceNode()
            target_node = edge.targetNode()

            if source_node is None or target_node is None:
                # Not serializing dangling nodes
                continue

            edge_data = {
                &#34;source&#34;: {
                    &#34;node_index&#34;: nodes.index(source_node),
                    &#34;connection_index&#34;: source_node.outputs.index(edge.source())
                },
                &#34;target&#34;: {
                    &#34;node_index&#34;: nodes.index(target_node),
                    &#34;connection_index&#34;: target_node.inputs.index(edge.target())
                }
            }

            data[&#34;edges&#34;].append(edge_data)

        return data
    
    def deserialize(self, data: dict):
        &#34;&#34;&#34;Deserialize this object from a dict of data.
        
        Edges are not serialized as objects. Instead, only their connections are remembered and reconstructed during the
        deserialization.
        &#34;&#34;&#34;
        self.clear()

        # Deserialize nodes --------------------------------------------------------------------------------------------
        for node in data[&#34;nodes&#34;]:
            self.add(node)

        # Deserialize edges --------------------------------------------------------------------------------------------
        for edge_data in data[&#34;edges&#34;]:
            source_node = data[&#34;nodes&#34;][edge_data[&#34;source&#34;][&#34;node_index&#34;]]
            target_node = data[&#34;nodes&#34;][edge_data[&#34;target&#34;][&#34;node_index&#34;]]

            source = source_node.outputs[edge_data[&#34;source&#34;][&#34;connection_index&#34;]]
            target = target_node.inputs[edge_data[&#34;target&#34;][&#34;connection_index&#34;]]

            self.connect_nodes(source, target)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="nfb_studio.widgets.scheme.graphics_item_group.GraphicsItemGroup" href="graphics_item_group.html#nfb_studio.widgets.scheme.graphics_item_group.GraphicsItemGroup">GraphicsItemGroup</a></li>
<li>collections.abc.MutableSet</li>
<li>collections.abc.Set</li>
<li>collections.abc.Collection</li>
<li>collections.abc.Sized</li>
<li>collections.abc.Iterable</li>
<li>collections.abc.Container</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="nfb_studio.widgets.scheme.graph.Graph.clipboardSelection"><code class="name flex">
<span>def <span class="ident">clipboardSelection</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return a Graph containing all selected nodes and edges, suitable for copying to clipboard.</p>
<p>This selection is similar to <code>self.selection()</code> in that it only contains nodes and edges highlighted to the
user. The difference is that if the user selected only edges, this is considered unsuitable for copying and an
empty graph is returned instead.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clipboardSelection(self):
    &#34;&#34;&#34;Return a Graph containing all selected nodes and edges, suitable for copying to clipboard.
    
    This selection is similar to `self.selection()` in that it only contains nodes and edges highlighted to the
    user. The difference is that if the user selected only edges, this is considered unsuitable for copying and an
    empty graph is returned instead.
    &#34;&#34;&#34;
    result = self.selection()

    if len(result.nodes) == 0:
        return Graph()

    return result</code></pre>
</details>
</dd>
<dt id="nfb_studio.widgets.scheme.graph.Graph.connect_nodes"><code class="name flex">
<span>def <span class="ident">connect_nodes</span></span>(<span>self, source: <a title="nfb_studio.widgets.scheme.node.connection.output.Output" href="node/connection/output.html#nfb_studio.widgets.scheme.node.connection.output.Output">Output</a>, target: <a title="nfb_studio.widgets.scheme.node.connection.input.Input" href="node/connection/input.html#nfb_studio.widgets.scheme.node.connection.input.Input">Input</a>) ‑> <a title="nfb_studio.widgets.scheme.node.edge.Edge" href="node/edge.html#nfb_studio.widgets.scheme.node.edge.Edge">Edge</a></span>
</code></dt>
<dd>
<div class="desc"><p>Connect an Output connection to an Input connection with an edge.</p>
<p>Returns the newly created edge.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def connect_nodes(self, source: Output, target: Input) -&gt; Edge:
    &#34;&#34;&#34;Connect an Output connection to an Input connection with an edge.
    
    Returns the newly created edge.
    &#34;&#34;&#34;
    edge = Edge()
    edge.setSource(source)
    edge.setTarget(target)

    self.add(edge)
    return edge</code></pre>
</details>
</dd>
<dt id="nfb_studio.widgets.scheme.graph.Graph.deserialize"><code class="name flex">
<span>def <span class="ident">deserialize</span></span>(<span>self, data: dict)</span>
</code></dt>
<dd>
<div class="desc"><p>Deserialize this object from a dict of data.</p>
<p>Edges are not serialized as objects. Instead, only their connections are remembered and reconstructed during the
deserialization.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def deserialize(self, data: dict):
    &#34;&#34;&#34;Deserialize this object from a dict of data.
    
    Edges are not serialized as objects. Instead, only their connections are remembered and reconstructed during the
    deserialization.
    &#34;&#34;&#34;
    self.clear()

    # Deserialize nodes --------------------------------------------------------------------------------------------
    for node in data[&#34;nodes&#34;]:
        self.add(node)

    # Deserialize edges --------------------------------------------------------------------------------------------
    for edge_data in data[&#34;edges&#34;]:
        source_node = data[&#34;nodes&#34;][edge_data[&#34;source&#34;][&#34;node_index&#34;]]
        target_node = data[&#34;nodes&#34;][edge_data[&#34;target&#34;][&#34;node_index&#34;]]

        source = source_node.outputs[edge_data[&#34;source&#34;][&#34;connection_index&#34;]]
        target = target_node.inputs[edge_data[&#34;target&#34;][&#34;connection_index&#34;]]

        self.connect_nodes(source, target)</code></pre>
</details>
</dd>
<dt id="nfb_studio.widgets.scheme.graph.Graph.disconnect_nodes"><code class="name flex">
<span>def <span class="ident">disconnect_nodes</span></span>(<span>self, source: <a title="nfb_studio.widgets.scheme.node.connection.output.Output" href="node/connection/output.html#nfb_studio.widgets.scheme.node.connection.output.Output">Output</a>, target: <a title="nfb_studio.widgets.scheme.node.connection.input.Input" href="node/connection/input.html#nfb_studio.widgets.scheme.node.connection.input.Input">Input</a>) ‑> typing.Union[<a title="nfb_studio.widgets.scheme.node.edge.Edge" href="node/edge.html#nfb_studio.widgets.scheme.node.edge.Edge">Edge</a>, NoneType]</span>
</code></dt>
<dd>
<div class="desc"><p>Remove a connection between a node output and an input.</p>
<p>If output and input are connected more than once, only one edge is removed.
Returns the edge that was removed, or None if no such edge was found.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def disconnect_nodes(self, source: Output, target: Input) -&gt; Union[Edge, None]:
    &#34;&#34;&#34;Remove a connection between a node output and an input.
    
    If output and input are connected more than once, only one edge is removed.
    Returns the edge that was removed, or None if no such edge was found.
    &#34;&#34;&#34;
    for edge in self.edges:
        if edge.source() == source and edge.target() == target:
            self.discard(edge)
            return edge
    return None</code></pre>
</details>
</dd>
<dt id="nfb_studio.widgets.scheme.graph.Graph.extract"><code class="name flex">
<span>def <span class="ident">extract</span></span>(<span>self, other)</span>
</code></dt>
<dd>
<div class="desc"><p>Extract other graph from this graph.</p>
<p>After calling this function, self.isdisjoint(other) will return True. All edges that become dangling from node
removal are also removed.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def extract(self, other):
    &#34;&#34;&#34;Extract other graph from this graph.
    
    After calling this function, self.isdisjoint(other) will return True. All edges that become dangling from node
    removal are also removed.
    &#34;&#34;&#34;
    for edge in other.edges:
        self.discard(edge)

    for node in other.nodes:
        self.discard(node)</code></pre>
</details>
</dd>
<dt id="nfb_studio.widgets.scheme.graph.Graph.merge"><code class="name flex">
<span>def <span class="ident">merge</span></span>(<span>self, other)</span>
</code></dt>
<dd>
<div class="desc"><p>Merge other graph into this graph.</p>
<p>After calling this function, other.issubset(self) will return True.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def merge(self, other):
    &#34;&#34;&#34;Merge other graph into this graph.
    
    After calling this function, other.issubset(self) will return True.
    &#34;&#34;&#34;
    super().__ior__(other)
    self.nodes |= other.nodes
    self.edges |= other.edges</code></pre>
</details>
</dd>
<dt id="nfb_studio.widgets.scheme.graph.Graph.selectAll"><code class="name flex">
<span>def <span class="ident">selectAll</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Select the whole graph.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def selectAll(self):
    &#34;&#34;&#34;Select the whole graph.&#34;&#34;&#34;
    for node in self.nodes:
        node.setSelected(True)</code></pre>
</details>
</dd>
<dt id="nfb_studio.widgets.scheme.graph.Graph.selection"><code class="name flex">
<span>def <span class="ident">selection</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return a Graph containing all selected nodes and edges.</p>
<p>This selection is equivalent to the highlighted items the user sees on screen. This means that it is possible
that the resulting graph will contain only edges and no nodes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def selection(self):
    &#34;&#34;&#34;Return a Graph containing all selected nodes and edges.
    
    This selection is equivalent to the highlighted items the user sees on screen. This means that it is possible
    that the resulting graph will contain only edges and no nodes.
    &#34;&#34;&#34;
    result = Graph()

    for item in self:
        if item.isSelected():
            result.add(item)

    return result</code></pre>
</details>
</dd>
<dt id="nfb_studio.widgets.scheme.graph.Graph.serialize"><code class="name flex">
<span>def <span class="ident">serialize</span></span>(<span>self) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def serialize(self) -&gt; dict:
    data = {}

    # Serialize nodes ----------------------------------------------------------------------------------------------
    nodes = list(self.nodes)
    data[&#34;nodes&#34;] = nodes

    # Serialize edges ----------------------------------------------------------------------------------------------
    data[&#34;edges&#34;] = []

    for edge in self.edges:
        source_node = edge.sourceNode()
        target_node = edge.targetNode()

        if source_node is None or target_node is None:
            # Not serializing dangling nodes
            continue

        edge_data = {
            &#34;source&#34;: {
                &#34;node_index&#34;: nodes.index(source_node),
                &#34;connection_index&#34;: source_node.outputs.index(edge.source())
            },
            &#34;target&#34;: {
                &#34;node_index&#34;: nodes.index(target_node),
                &#34;connection_index&#34;: target_node.inputs.index(edge.target())
            }
        }

        data[&#34;edges&#34;].append(edge_data)

    return data</code></pre>
</details>
</dd>
<dt id="nfb_studio.widgets.scheme.graph.Graph.wideSelection"><code class="name flex">
<span>def <span class="ident">wideSelection</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return a graph snapshot containing all selected nodes and all connected edges.</p>
<p>Unlike <code>self.selection()</code>, this method also gets all edges where at least one end is a selected node.<br>
This snapshot is equivalent to the items that are deleted when a selection is removed or cut.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def wideSelection(self):
    &#34;&#34;&#34;Return a graph snapshot containing all selected nodes and all connected edges.
    
    Unlike `self.selection()`, this method also gets all edges where at least one end is a selected node.  
    This snapshot is equivalent to the items that are deleted when a selection is removed or cut.
    &#34;&#34;&#34;
    result = self.selection()

    for edge in self.edges:
        if ((edge.sourceNode() is not None and self.sourceNode().isSelected()) or 
            (edge.targetNode() is not None and self.targetNode().isSelected())):
            result.add(edge)  

    return result</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="nfb_studio.widgets.scheme.graphics_item_group.GraphicsItemGroup" href="graphics_item_group.html#nfb_studio.widgets.scheme.graphics_item_group.GraphicsItemGroup">GraphicsItemGroup</a></b></code>:
<ul class="hlist">
<li><code><a title="nfb_studio.widgets.scheme.graphics_item_group.GraphicsItemGroup.add" href="graphics_item_group.html#nfb_studio.widgets.scheme.graphics_item_group.GraphicsItemGroup.add">add</a></code></li>
<li><code><a title="nfb_studio.widgets.scheme.graphics_item_group.GraphicsItemGroup.discard" href="graphics_item_group.html#nfb_studio.widgets.scheme.graphics_item_group.GraphicsItemGroup.discard">discard</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="nfb_studio.widgets.scheme" href="index.html">nfb_studio.widgets.scheme</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="nfb_studio.widgets.scheme.graph.Graph" href="#nfb_studio.widgets.scheme.graph.Graph">Graph</a></code></h4>
<ul class="two-column">
<li><code><a title="nfb_studio.widgets.scheme.graph.Graph.clipboardSelection" href="#nfb_studio.widgets.scheme.graph.Graph.clipboardSelection">clipboardSelection</a></code></li>
<li><code><a title="nfb_studio.widgets.scheme.graph.Graph.connect_nodes" href="#nfb_studio.widgets.scheme.graph.Graph.connect_nodes">connect_nodes</a></code></li>
<li><code><a title="nfb_studio.widgets.scheme.graph.Graph.deserialize" href="#nfb_studio.widgets.scheme.graph.Graph.deserialize">deserialize</a></code></li>
<li><code><a title="nfb_studio.widgets.scheme.graph.Graph.disconnect_nodes" href="#nfb_studio.widgets.scheme.graph.Graph.disconnect_nodes">disconnect_nodes</a></code></li>
<li><code><a title="nfb_studio.widgets.scheme.graph.Graph.extract" href="#nfb_studio.widgets.scheme.graph.Graph.extract">extract</a></code></li>
<li><code><a title="nfb_studio.widgets.scheme.graph.Graph.merge" href="#nfb_studio.widgets.scheme.graph.Graph.merge">merge</a></code></li>
<li><code><a title="nfb_studio.widgets.scheme.graph.Graph.selectAll" href="#nfb_studio.widgets.scheme.graph.Graph.selectAll">selectAll</a></code></li>
<li><code><a title="nfb_studio.widgets.scheme.graph.Graph.selection" href="#nfb_studio.widgets.scheme.graph.Graph.selection">selection</a></code></li>
<li><code><a title="nfb_studio.widgets.scheme.graph.Graph.serialize" href="#nfb_studio.widgets.scheme.graph.Graph.serialize">serialize</a></code></li>
<li><code><a title="nfb_studio.widgets.scheme.graph.Graph.wideSelection" href="#nfb_studio.widgets.scheme.graph.Graph.wideSelection">wideSelection</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.3</a>.</p>
</footer>
</body>
</html>