<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.7.5" />
<title>nfb_studio.widgets.scheme.graph API documentation</title>
<meta name="description" content="Classes representing the graph stucture in the signal scheme." />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>nfb_studio.widgets.scheme.graph</code></h1>
</header>
<section id="section-intro">
<p>Classes representing the graph stucture in the signal scheme.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;Classes representing the graph stucture in the signal scheme.&#34;&#34;&#34;
from typing import Union

from PySide2.QtCore import QRectF

from .node import Node
from .edge import Edge
from .connection import Input, Output


class AbstractGraph:
    &#34;&#34;&#34;An abstract (not supposed to be created) base class for Graph and GraphSnapshot.
    
    Both Graph and GraphSnapshot contain two members - `self.nodes` and `self.edges`. In Graph those are sets, in
    GraphSnapshot - frozensets.
    &#34;&#34;&#34;
    def __init__(self):
        self.nodes = None  # Defined in implementations
        self.edges = None  # Defined in implementations

    # Selection ========================================================================================================
    def selectAll(self):
        &#34;&#34;&#34;Select the whole graph.&#34;&#34;&#34;
        for node in self.nodes:
            node.setSelected(True)

    def selection(self):
        &#34;&#34;&#34;Return a GraphSnapshot containing all selected nodes and edges.
        
        Edges count as selected if nodes on both ends are selected. This snapshot is equivalent to the data that ends up
        in the clipboard when a selection is copied.
        &#34;&#34;&#34;
        result = GraphSnapshot()

        selected_nodes = [node for node in self.nodes if node.isSelected()]
        selected_edges = [edge for edge in self.edges if edge.isSelected()]

        result.nodes = frozenset(selected_nodes)
        result.edges = frozenset(selected_edges)

        return result
    
    def wideSelection(self):
        &#34;&#34;&#34;Return a graph snapshot containing all selected nodes and all connected edges.
        
        Unlike `selection()`, this method also gets all edges where at least one end is a selected node.
        This snapshot is equivalent to the items that are deleted when a selection is removed or cut.
        &#34;&#34;&#34;
        result = GraphSnapshot()

        selected_nodes = [node for node in self.nodes if node.isSelected()]
        
        selected_edges = []
        for edge in self.edges:
            if ((edge.sourceNode() is not None and self.sourceNode().isSelected()) or 
                (edge.targetNode() is not None and self.targetNode().isSelected())):
                selected_edges.append(edge)  

        result.nodes = frozenset(selected_nodes)
        result.edges = frozenset(selected_edges)

        return result

    # Observer functions ===============================================================================================
    def findNode(self, node_id: int) -&gt; Union[Node, None]:
        &#34;&#34;&#34;Find and return a node that has the corresponding id.
        
        If no such node could be found, return None.
        &#34;&#34;&#34;
        for node in self.nodes:
            if node_id == id(node):
                return node
        return None

    # Transformations ==================================================================================================
    def boundingRect(self) -&gt; QRectF:
        &#34;&#34;&#34;Return the combined bounding box of all the items in the graph.&#34;&#34;&#34;
        result = QRectF()

        for node in self.nodes:
            result = result | node.boundingRect() | node.childrenBoundingRect()
        for edge in self.edge:
            result = result | edge.boundingRect() | edge.childrenBoundingRect()
        
        return result

    def moveBy(self, dx, dy):
        &#34;&#34;&#34;Move all nodes by some offset.&#34;&#34;&#34;
        for node in self.nodes:
            node.moveBy(dx, dy)

    # Utility functions ================================================================================================
    def __len__(self):
        &#34;&#34;&#34;Size of the graph. Equal to len(self.nodes).&#34;&#34;&#34;
        return len(self.nodes)
    
    def __contains__(self, obj, /):
        &#34;&#34;&#34;Check if the graph contains a node or an edge.&#34;&#34;&#34;
        if isinstance(obj, Node):
            return obj in self.nodes
        elif isinstance(obj, Edge):
            return obj in self.edges
        return False
    
    def isdisjoint(self, other):
        &#34;&#34;&#34;Return True if the graph has no elements in common with other.
        
        Dangling nodes are not considered valid parts of a graph. They can only exist as temporary objects.
        This means that if no nodes are shared, no edges can be shared. If nodes are shared, the graph is already not
        disjoint. For this reason edges are not checked.
        &#34;&#34;&#34;
        return self.nodes.isdisjoint(other.nodes)

    def issubset(self, other):
        &#34;&#34;&#34;Test whether every element in the set is in other.&#34;&#34;&#34;
        return self.nodes.issubset(other.nodes) and self.edges.issubset(other.edges)
    
    def issuperset(self, other):
        &#34;&#34;&#34;Test whether every element in other is in the set.&#34;&#34;&#34;
        return other.issubset(self)

    # Serialization ====================================================================================================
    def serialize(self) -&gt; dict:
        data = {}

        # Serialize nodes ----------------------------------------------------------------------------------------------
        nodes = list(self.nodes)
        data[&#34;nodes&#34;] = nodes

        # Serialize edges ----------------------------------------------------------------------------------------------
        data[&#34;edges&#34;] = []

        for edge in self.edges:
            source_node = edge.sourceNode()
            target_node = edge.targetNode()

            if source_node is None or target_node is None:
                # Not serializing dangling nodes
                continue

            edge_data = {
                &#34;source&#34;: {
                    &#34;node_index&#34;: nodes.index(source_node),
                    &#34;connection_index&#34;: source_node.outputs.index(edge.source())
                },
                &#34;target&#34;: {
                    &#34;node_index&#34;: nodes.index(target_node),
                    &#34;connection_index&#34;: target_node.inputs.index(edge.target())
                }
            }

            data[&#34;edges&#34;].append(edge_data)

        return data


class Graph(AbstractGraph):
    &#34;&#34;&#34;A collection of nodes and edges connecting them.&#34;&#34;&#34;

    def __init__(self):
        super().__init__()

        self.nodes = set()
        self.edges = set()

    def addNode(self, node: Node):
        &#34;&#34;&#34;Add a new node to this graph.&#34;&#34;&#34;
        self.nodes.add(node)

    def addEdge(self, edge: Edge):
        &#34;&#34;&#34;Add a new edge to this graph.
        
        The both source and target nodes of this edge must already be present in the graph. Otherwise, ValueError is
        raised.
        &#34;&#34;&#34;
        # Check that this edge is valid, that is both its source and target are in the scene (if they exist)
        if (edge.sourceNode() is None or edge.sourceNode() in self.nodes) and \
           (edge.targetNode() is None or edge.targetNode() in self.nodes):

            self.edges.add(edge)
        else:
            raise ValueError(&#34;one of edge&#39;s connections is not in this graph&#34;)

    def removeNode(self, node: Node):
        &#34;&#34;&#34;Remove a node from this graph.
        
        If a node is removed, all edges to or from that node are also removed.
        &#34;&#34;&#34;
        # Remove connected edges
        to_remove = []
        for edge in self.edges:
            if edge.sourceNode() == node or edge.targetNode() == node:
                to_remove.append(edge)
        
        for edge in to_remove:
            self.removeEdge(edge)

        # Remove the node
        self.nodes.remove(node)

    def removeEdge(self, edge: Edge):
        &#34;&#34;&#34;Remove an edge from this graph.&#34;&#34;&#34;
        self.edges.remove(edge)
        edge.detachAll()  # Disconnect from nodes that are still in this graph

    def connect_nodes(self, source: Output, target: Input) -&gt; Edge:
        &#34;&#34;&#34;Connect an Output connection to an Input connection with an edge.
        
        Returns the newly created edge.
        &#34;&#34;&#34;
        edge = Edge()
        edge.setSource(source)
        edge.setTarget(target)

        self.addEdge(edge)
        return edge

    def disconnect_nodes(self, source: Output, target: Input) -&gt; Union[Edge, None]:
        &#34;&#34;&#34;Remove a connection between a node output and an input.
        
        If output and input are connected more than once, only one edge is removed.
        Returns the edge that was removed, or None if no such edge was found.
        &#34;&#34;&#34;
        for edge in self.edges:
            if edge.source() == source and edge.target() == target:
                self.removeEdge(edge)
                return edge
        return None

    # def serialize(self) -&gt; dict  # Inherited from AbstractGraph

    def deserialize(self, data: dict):
        &#34;&#34;&#34;Deserialize this object from a dict of data.
        
        Edges are not serialized as objects. Instead, only their connections are remembered and reconstructed during the
        deserialization.
        &#34;&#34;&#34;
        self.clear()

        # Deserialize nodes --------------------------------------------------------------------------------------------
        for node in data[&#34;nodes&#34;]:
            self.addNode(node)

        # Deserialize edges --------------------------------------------------------------------------------------------
        for edge_data in data[&#34;edges&#34;]:
            source_node = data[&#34;nodes&#34;][edge_data[&#34;source&#34;][&#34;node_index&#34;]]
            target_node = data[&#34;nodes&#34;][edge_data[&#34;target&#34;][&#34;node_index&#34;]]

            source = source_node.outputs[edge_data[&#34;source&#34;][&#34;connection_index&#34;]]
            target = target_node.inputs[edge_data[&#34;target&#34;][&#34;connection_index&#34;]]

            self.connect_nodes(source, target)
    
    def extract(self, other: AbstractGraph):
        &#34;&#34;&#34;Extract other graph from this graph.
        
        After calling this function, self.isdisjoint(other) will return True. All edges that become dangling from node
        removal are also removed.
        &#34;&#34;&#34;
        for node in other.nodes:
            self.removeNode(node)

    def merge(self, other: AbstractGraph):
        &#34;&#34;&#34;Merge other graph into this graph.
        
        After calling this function, other.issubset(self) will return True.
        &#34;&#34;&#34;
        self.nodes.update(other.nodes)
        self.edges.update(other.edges)
    
    def clear(self):
        for node in self.nodes:
            self.removeNode(node)


class GraphSnapshot(AbstractGraph):
    &#34;&#34;&#34;A static reference to a part of a graph. Contains a frozenset of nodes and a frozenset of edges.

    A snapshot is not meant to be edited.
    &#34;&#34;&#34;
    def __init__(self, nodes=None, edges=None):
        super().__init__()

        self.nodes = nodes or frozenset()
        self.edges = edges or frozenset()

    # def serialize(self) -&gt; dict  # Inherited from AbstractGraph

    def deserialize(self, data: dict):
        &#34;&#34;&#34;Deserialize this object from a dict of data.
        
        This functions deserializes by loading data into a mutable Graph, then freezing it in a frozenset.
        &#34;&#34;&#34;
        g = Graph()
        g.deserialize(data)

        self.nodes = frozenset(g.nodes)
        self.edges = frozenset(g.edges)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="nfb_studio.widgets.scheme.graph.AbstractGraph"><code class="flex name class">
<span>class <span class="ident">AbstractGraph</span></span>
</code></dt>
<dd>
<section class="desc"><p>An abstract (not supposed to be created) base class for Graph and GraphSnapshot.</p>
<p>Both Graph and GraphSnapshot contain two members - <code>self.nodes</code> and <code>self.edges</code>. In Graph those are sets, in
GraphSnapshot - frozensets.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AbstractGraph:
    &#34;&#34;&#34;An abstract (not supposed to be created) base class for Graph and GraphSnapshot.
    
    Both Graph and GraphSnapshot contain two members - `self.nodes` and `self.edges`. In Graph those are sets, in
    GraphSnapshot - frozensets.
    &#34;&#34;&#34;
    def __init__(self):
        self.nodes = None  # Defined in implementations
        self.edges = None  # Defined in implementations

    # Selection ========================================================================================================
    def selectAll(self):
        &#34;&#34;&#34;Select the whole graph.&#34;&#34;&#34;
        for node in self.nodes:
            node.setSelected(True)

    def selection(self):
        &#34;&#34;&#34;Return a GraphSnapshot containing all selected nodes and edges.
        
        Edges count as selected if nodes on both ends are selected. This snapshot is equivalent to the data that ends up
        in the clipboard when a selection is copied.
        &#34;&#34;&#34;
        result = GraphSnapshot()

        selected_nodes = [node for node in self.nodes if node.isSelected()]
        selected_edges = [edge for edge in self.edges if edge.isSelected()]

        result.nodes = frozenset(selected_nodes)
        result.edges = frozenset(selected_edges)

        return result
    
    def wideSelection(self):
        &#34;&#34;&#34;Return a graph snapshot containing all selected nodes and all connected edges.
        
        Unlike `selection()`, this method also gets all edges where at least one end is a selected node.
        This snapshot is equivalent to the items that are deleted when a selection is removed or cut.
        &#34;&#34;&#34;
        result = GraphSnapshot()

        selected_nodes = [node for node in self.nodes if node.isSelected()]
        
        selected_edges = []
        for edge in self.edges:
            if ((edge.sourceNode() is not None and self.sourceNode().isSelected()) or 
                (edge.targetNode() is not None and self.targetNode().isSelected())):
                selected_edges.append(edge)  

        result.nodes = frozenset(selected_nodes)
        result.edges = frozenset(selected_edges)

        return result

    # Observer functions ===============================================================================================
    def findNode(self, node_id: int) -&gt; Union[Node, None]:
        &#34;&#34;&#34;Find and return a node that has the corresponding id.
        
        If no such node could be found, return None.
        &#34;&#34;&#34;
        for node in self.nodes:
            if node_id == id(node):
                return node
        return None

    # Transformations ==================================================================================================
    def boundingRect(self) -&gt; QRectF:
        &#34;&#34;&#34;Return the combined bounding box of all the items in the graph.&#34;&#34;&#34;
        result = QRectF()

        for node in self.nodes:
            result = result | node.boundingRect() | node.childrenBoundingRect()
        for edge in self.edge:
            result = result | edge.boundingRect() | edge.childrenBoundingRect()
        
        return result

    def moveBy(self, dx, dy):
        &#34;&#34;&#34;Move all nodes by some offset.&#34;&#34;&#34;
        for node in self.nodes:
            node.moveBy(dx, dy)

    # Utility functions ================================================================================================
    def __len__(self):
        &#34;&#34;&#34;Size of the graph. Equal to len(self.nodes).&#34;&#34;&#34;
        return len(self.nodes)
    
    def __contains__(self, obj, /):
        &#34;&#34;&#34;Check if the graph contains a node or an edge.&#34;&#34;&#34;
        if isinstance(obj, Node):
            return obj in self.nodes
        elif isinstance(obj, Edge):
            return obj in self.edges
        return False
    
    def isdisjoint(self, other):
        &#34;&#34;&#34;Return True if the graph has no elements in common with other.
        
        Dangling nodes are not considered valid parts of a graph. They can only exist as temporary objects.
        This means that if no nodes are shared, no edges can be shared. If nodes are shared, the graph is already not
        disjoint. For this reason edges are not checked.
        &#34;&#34;&#34;
        return self.nodes.isdisjoint(other.nodes)

    def issubset(self, other):
        &#34;&#34;&#34;Test whether every element in the set is in other.&#34;&#34;&#34;
        return self.nodes.issubset(other.nodes) and self.edges.issubset(other.edges)
    
    def issuperset(self, other):
        &#34;&#34;&#34;Test whether every element in other is in the set.&#34;&#34;&#34;
        return other.issubset(self)

    # Serialization ====================================================================================================
    def serialize(self) -&gt; dict:
        data = {}

        # Serialize nodes ----------------------------------------------------------------------------------------------
        nodes = list(self.nodes)
        data[&#34;nodes&#34;] = nodes

        # Serialize edges ----------------------------------------------------------------------------------------------
        data[&#34;edges&#34;] = []

        for edge in self.edges:
            source_node = edge.sourceNode()
            target_node = edge.targetNode()

            if source_node is None or target_node is None:
                # Not serializing dangling nodes
                continue

            edge_data = {
                &#34;source&#34;: {
                    &#34;node_index&#34;: nodes.index(source_node),
                    &#34;connection_index&#34;: source_node.outputs.index(edge.source())
                },
                &#34;target&#34;: {
                    &#34;node_index&#34;: nodes.index(target_node),
                    &#34;connection_index&#34;: target_node.inputs.index(edge.target())
                }
            }

            data[&#34;edges&#34;].append(edge_data)

        return data</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="nfb_studio.widgets.scheme.graph.Graph" href="#nfb_studio.widgets.scheme.graph.Graph">Graph</a></li>
<li><a title="nfb_studio.widgets.scheme.graph.GraphSnapshot" href="#nfb_studio.widgets.scheme.graph.GraphSnapshot">GraphSnapshot</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="nfb_studio.widgets.scheme.graph.AbstractGraph.boundingRect"><code class="name flex">
<span>def <span class="ident">boundingRect</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Return the combined bounding box of all the items in the graph.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def boundingRect(self) -&gt; QRectF:
    &#34;&#34;&#34;Return the combined bounding box of all the items in the graph.&#34;&#34;&#34;
    result = QRectF()

    for node in self.nodes:
        result = result | node.boundingRect() | node.childrenBoundingRect()
    for edge in self.edge:
        result = result | edge.boundingRect() | edge.childrenBoundingRect()
    
    return result</code></pre>
</details>
</dd>
<dt id="nfb_studio.widgets.scheme.graph.AbstractGraph.findNode"><code class="name flex">
<span>def <span class="ident">findNode</span></span>(<span>self, node_id)</span>
</code></dt>
<dd>
<section class="desc"><p>Find and return a node that has the corresponding id.</p>
<p>If no such node could be found, return None.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def findNode(self, node_id: int) -&gt; Union[Node, None]:
    &#34;&#34;&#34;Find and return a node that has the corresponding id.
    
    If no such node could be found, return None.
    &#34;&#34;&#34;
    for node in self.nodes:
        if node_id == id(node):
            return node
    return None</code></pre>
</details>
</dd>
<dt id="nfb_studio.widgets.scheme.graph.AbstractGraph.isdisjoint"><code class="name flex">
<span>def <span class="ident">isdisjoint</span></span>(<span>self, other)</span>
</code></dt>
<dd>
<section class="desc"><p>Return True if the graph has no elements in common with other.</p>
<p>Dangling nodes are not considered valid parts of a graph. They can only exist as temporary objects.
This means that if no nodes are shared, no edges can be shared. If nodes are shared, the graph is already not
disjoint. For this reason edges are not checked.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def isdisjoint(self, other):
    &#34;&#34;&#34;Return True if the graph has no elements in common with other.
    
    Dangling nodes are not considered valid parts of a graph. They can only exist as temporary objects.
    This means that if no nodes are shared, no edges can be shared. If nodes are shared, the graph is already not
    disjoint. For this reason edges are not checked.
    &#34;&#34;&#34;
    return self.nodes.isdisjoint(other.nodes)</code></pre>
</details>
</dd>
<dt id="nfb_studio.widgets.scheme.graph.AbstractGraph.issubset"><code class="name flex">
<span>def <span class="ident">issubset</span></span>(<span>self, other)</span>
</code></dt>
<dd>
<section class="desc"><p>Test whether every element in the set is in other.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def issubset(self, other):
    &#34;&#34;&#34;Test whether every element in the set is in other.&#34;&#34;&#34;
    return self.nodes.issubset(other.nodes) and self.edges.issubset(other.edges)</code></pre>
</details>
</dd>
<dt id="nfb_studio.widgets.scheme.graph.AbstractGraph.issuperset"><code class="name flex">
<span>def <span class="ident">issuperset</span></span>(<span>self, other)</span>
</code></dt>
<dd>
<section class="desc"><p>Test whether every element in other is in the set.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def issuperset(self, other):
    &#34;&#34;&#34;Test whether every element in other is in the set.&#34;&#34;&#34;
    return other.issubset(self)</code></pre>
</details>
</dd>
<dt id="nfb_studio.widgets.scheme.graph.AbstractGraph.moveBy"><code class="name flex">
<span>def <span class="ident">moveBy</span></span>(<span>self, dx, dy)</span>
</code></dt>
<dd>
<section class="desc"><p>Move all nodes by some offset.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def moveBy(self, dx, dy):
    &#34;&#34;&#34;Move all nodes by some offset.&#34;&#34;&#34;
    for node in self.nodes:
        node.moveBy(dx, dy)</code></pre>
</details>
</dd>
<dt id="nfb_studio.widgets.scheme.graph.AbstractGraph.selectAll"><code class="name flex">
<span>def <span class="ident">selectAll</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Select the whole graph.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def selectAll(self):
    &#34;&#34;&#34;Select the whole graph.&#34;&#34;&#34;
    for node in self.nodes:
        node.setSelected(True)</code></pre>
</details>
</dd>
<dt id="nfb_studio.widgets.scheme.graph.AbstractGraph.selection"><code class="name flex">
<span>def <span class="ident">selection</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Return a GraphSnapshot containing all selected nodes and edges.</p>
<p>Edges count as selected if nodes on both ends are selected. This snapshot is equivalent to the data that ends up
in the clipboard when a selection is copied.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def selection(self):
    &#34;&#34;&#34;Return a GraphSnapshot containing all selected nodes and edges.
    
    Edges count as selected if nodes on both ends are selected. This snapshot is equivalent to the data that ends up
    in the clipboard when a selection is copied.
    &#34;&#34;&#34;
    result = GraphSnapshot()

    selected_nodes = [node for node in self.nodes if node.isSelected()]
    selected_edges = [edge for edge in self.edges if edge.isSelected()]

    result.nodes = frozenset(selected_nodes)
    result.edges = frozenset(selected_edges)

    return result</code></pre>
</details>
</dd>
<dt id="nfb_studio.widgets.scheme.graph.AbstractGraph.serialize"><code class="name flex">
<span>def <span class="ident">serialize</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def serialize(self) -&gt; dict:
    data = {}

    # Serialize nodes ----------------------------------------------------------------------------------------------
    nodes = list(self.nodes)
    data[&#34;nodes&#34;] = nodes

    # Serialize edges ----------------------------------------------------------------------------------------------
    data[&#34;edges&#34;] = []

    for edge in self.edges:
        source_node = edge.sourceNode()
        target_node = edge.targetNode()

        if source_node is None or target_node is None:
            # Not serializing dangling nodes
            continue

        edge_data = {
            &#34;source&#34;: {
                &#34;node_index&#34;: nodes.index(source_node),
                &#34;connection_index&#34;: source_node.outputs.index(edge.source())
            },
            &#34;target&#34;: {
                &#34;node_index&#34;: nodes.index(target_node),
                &#34;connection_index&#34;: target_node.inputs.index(edge.target())
            }
        }

        data[&#34;edges&#34;].append(edge_data)

    return data</code></pre>
</details>
</dd>
<dt id="nfb_studio.widgets.scheme.graph.AbstractGraph.wideSelection"><code class="name flex">
<span>def <span class="ident">wideSelection</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Return a graph snapshot containing all selected nodes and all connected edges.</p>
<p>Unlike <code>selection()</code>, this method also gets all edges where at least one end is a selected node.
This snapshot is equivalent to the items that are deleted when a selection is removed or cut.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def wideSelection(self):
    &#34;&#34;&#34;Return a graph snapshot containing all selected nodes and all connected edges.
    
    Unlike `selection()`, this method also gets all edges where at least one end is a selected node.
    This snapshot is equivalent to the items that are deleted when a selection is removed or cut.
    &#34;&#34;&#34;
    result = GraphSnapshot()

    selected_nodes = [node for node in self.nodes if node.isSelected()]
    
    selected_edges = []
    for edge in self.edges:
        if ((edge.sourceNode() is not None and self.sourceNode().isSelected()) or 
            (edge.targetNode() is not None and self.targetNode().isSelected())):
            selected_edges.append(edge)  

    result.nodes = frozenset(selected_nodes)
    result.edges = frozenset(selected_edges)

    return result</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="nfb_studio.widgets.scheme.graph.Graph"><code class="flex name class">
<span>class <span class="ident">Graph</span></span>
</code></dt>
<dd>
<section class="desc"><p>A collection of nodes and edges connecting them.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Graph(AbstractGraph):
    &#34;&#34;&#34;A collection of nodes and edges connecting them.&#34;&#34;&#34;

    def __init__(self):
        super().__init__()

        self.nodes = set()
        self.edges = set()

    def addNode(self, node: Node):
        &#34;&#34;&#34;Add a new node to this graph.&#34;&#34;&#34;
        self.nodes.add(node)

    def addEdge(self, edge: Edge):
        &#34;&#34;&#34;Add a new edge to this graph.
        
        The both source and target nodes of this edge must already be present in the graph. Otherwise, ValueError is
        raised.
        &#34;&#34;&#34;
        # Check that this edge is valid, that is both its source and target are in the scene (if they exist)
        if (edge.sourceNode() is None or edge.sourceNode() in self.nodes) and \
           (edge.targetNode() is None or edge.targetNode() in self.nodes):

            self.edges.add(edge)
        else:
            raise ValueError(&#34;one of edge&#39;s connections is not in this graph&#34;)

    def removeNode(self, node: Node):
        &#34;&#34;&#34;Remove a node from this graph.
        
        If a node is removed, all edges to or from that node are also removed.
        &#34;&#34;&#34;
        # Remove connected edges
        to_remove = []
        for edge in self.edges:
            if edge.sourceNode() == node or edge.targetNode() == node:
                to_remove.append(edge)
        
        for edge in to_remove:
            self.removeEdge(edge)

        # Remove the node
        self.nodes.remove(node)

    def removeEdge(self, edge: Edge):
        &#34;&#34;&#34;Remove an edge from this graph.&#34;&#34;&#34;
        self.edges.remove(edge)
        edge.detachAll()  # Disconnect from nodes that are still in this graph

    def connect_nodes(self, source: Output, target: Input) -&gt; Edge:
        &#34;&#34;&#34;Connect an Output connection to an Input connection with an edge.
        
        Returns the newly created edge.
        &#34;&#34;&#34;
        edge = Edge()
        edge.setSource(source)
        edge.setTarget(target)

        self.addEdge(edge)
        return edge

    def disconnect_nodes(self, source: Output, target: Input) -&gt; Union[Edge, None]:
        &#34;&#34;&#34;Remove a connection between a node output and an input.
        
        If output and input are connected more than once, only one edge is removed.
        Returns the edge that was removed, or None if no such edge was found.
        &#34;&#34;&#34;
        for edge in self.edges:
            if edge.source() == source and edge.target() == target:
                self.removeEdge(edge)
                return edge
        return None

    # def serialize(self) -&gt; dict  # Inherited from AbstractGraph

    def deserialize(self, data: dict):
        &#34;&#34;&#34;Deserialize this object from a dict of data.
        
        Edges are not serialized as objects. Instead, only their connections are remembered and reconstructed during the
        deserialization.
        &#34;&#34;&#34;
        self.clear()

        # Deserialize nodes --------------------------------------------------------------------------------------------
        for node in data[&#34;nodes&#34;]:
            self.addNode(node)

        # Deserialize edges --------------------------------------------------------------------------------------------
        for edge_data in data[&#34;edges&#34;]:
            source_node = data[&#34;nodes&#34;][edge_data[&#34;source&#34;][&#34;node_index&#34;]]
            target_node = data[&#34;nodes&#34;][edge_data[&#34;target&#34;][&#34;node_index&#34;]]

            source = source_node.outputs[edge_data[&#34;source&#34;][&#34;connection_index&#34;]]
            target = target_node.inputs[edge_data[&#34;target&#34;][&#34;connection_index&#34;]]

            self.connect_nodes(source, target)
    
    def extract(self, other: AbstractGraph):
        &#34;&#34;&#34;Extract other graph from this graph.
        
        After calling this function, self.isdisjoint(other) will return True. All edges that become dangling from node
        removal are also removed.
        &#34;&#34;&#34;
        for node in other.nodes:
            self.removeNode(node)

    def merge(self, other: AbstractGraph):
        &#34;&#34;&#34;Merge other graph into this graph.
        
        After calling this function, other.issubset(self) will return True.
        &#34;&#34;&#34;
        self.nodes.update(other.nodes)
        self.edges.update(other.edges)
    
    def clear(self):
        for node in self.nodes:
            self.removeNode(node)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="nfb_studio.widgets.scheme.graph.AbstractGraph" href="#nfb_studio.widgets.scheme.graph.AbstractGraph">AbstractGraph</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="nfb_studio.widgets.scheme.graph.Graph.addEdge"><code class="name flex">
<span>def <span class="ident">addEdge</span></span>(<span>self, edge)</span>
</code></dt>
<dd>
<section class="desc"><p>Add a new edge to this graph.</p>
<p>The both source and target nodes of this edge must already be present in the graph. Otherwise, ValueError is
raised.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def addEdge(self, edge: Edge):
    &#34;&#34;&#34;Add a new edge to this graph.
    
    The both source and target nodes of this edge must already be present in the graph. Otherwise, ValueError is
    raised.
    &#34;&#34;&#34;
    # Check that this edge is valid, that is both its source and target are in the scene (if they exist)
    if (edge.sourceNode() is None or edge.sourceNode() in self.nodes) and \
       (edge.targetNode() is None or edge.targetNode() in self.nodes):

        self.edges.add(edge)
    else:
        raise ValueError(&#34;one of edge&#39;s connections is not in this graph&#34;)</code></pre>
</details>
</dd>
<dt id="nfb_studio.widgets.scheme.graph.Graph.addNode"><code class="name flex">
<span>def <span class="ident">addNode</span></span>(<span>self, node)</span>
</code></dt>
<dd>
<section class="desc"><p>Add a new node to this graph.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def addNode(self, node: Node):
    &#34;&#34;&#34;Add a new node to this graph.&#34;&#34;&#34;
    self.nodes.add(node)</code></pre>
</details>
</dd>
<dt id="nfb_studio.widgets.scheme.graph.Graph.clear"><code class="name flex">
<span>def <span class="ident">clear</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clear(self):
    for node in self.nodes:
        self.removeNode(node)</code></pre>
</details>
</dd>
<dt id="nfb_studio.widgets.scheme.graph.Graph.connect_nodes"><code class="name flex">
<span>def <span class="ident">connect_nodes</span></span>(<span>self, source, target)</span>
</code></dt>
<dd>
<section class="desc"><p>Connect an Output connection to an Input connection with an edge.</p>
<p>Returns the newly created edge.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def connect_nodes(self, source: Output, target: Input) -&gt; Edge:
    &#34;&#34;&#34;Connect an Output connection to an Input connection with an edge.
    
    Returns the newly created edge.
    &#34;&#34;&#34;
    edge = Edge()
    edge.setSource(source)
    edge.setTarget(target)

    self.addEdge(edge)
    return edge</code></pre>
</details>
</dd>
<dt id="nfb_studio.widgets.scheme.graph.Graph.deserialize"><code class="name flex">
<span>def <span class="ident">deserialize</span></span>(<span>self, data)</span>
</code></dt>
<dd>
<section class="desc"><p>Deserialize this object from a dict of data.</p>
<p>Edges are not serialized as objects. Instead, only their connections are remembered and reconstructed during the
deserialization.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def deserialize(self, data: dict):
    &#34;&#34;&#34;Deserialize this object from a dict of data.
    
    Edges are not serialized as objects. Instead, only their connections are remembered and reconstructed during the
    deserialization.
    &#34;&#34;&#34;
    self.clear()

    # Deserialize nodes --------------------------------------------------------------------------------------------
    for node in data[&#34;nodes&#34;]:
        self.addNode(node)

    # Deserialize edges --------------------------------------------------------------------------------------------
    for edge_data in data[&#34;edges&#34;]:
        source_node = data[&#34;nodes&#34;][edge_data[&#34;source&#34;][&#34;node_index&#34;]]
        target_node = data[&#34;nodes&#34;][edge_data[&#34;target&#34;][&#34;node_index&#34;]]

        source = source_node.outputs[edge_data[&#34;source&#34;][&#34;connection_index&#34;]]
        target = target_node.inputs[edge_data[&#34;target&#34;][&#34;connection_index&#34;]]

        self.connect_nodes(source, target)</code></pre>
</details>
</dd>
<dt id="nfb_studio.widgets.scheme.graph.Graph.disconnect_nodes"><code class="name flex">
<span>def <span class="ident">disconnect_nodes</span></span>(<span>self, source, target)</span>
</code></dt>
<dd>
<section class="desc"><p>Remove a connection between a node output and an input.</p>
<p>If output and input are connected more than once, only one edge is removed.
Returns the edge that was removed, or None if no such edge was found.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def disconnect_nodes(self, source: Output, target: Input) -&gt; Union[Edge, None]:
    &#34;&#34;&#34;Remove a connection between a node output and an input.
    
    If output and input are connected more than once, only one edge is removed.
    Returns the edge that was removed, or None if no such edge was found.
    &#34;&#34;&#34;
    for edge in self.edges:
        if edge.source() == source and edge.target() == target:
            self.removeEdge(edge)
            return edge
    return None</code></pre>
</details>
</dd>
<dt id="nfb_studio.widgets.scheme.graph.Graph.extract"><code class="name flex">
<span>def <span class="ident">extract</span></span>(<span>self, other)</span>
</code></dt>
<dd>
<section class="desc"><p>Extract other graph from this graph.</p>
<p>After calling this function, self.isdisjoint(other) will return True. All edges that become dangling from node
removal are also removed.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def extract(self, other: AbstractGraph):
    &#34;&#34;&#34;Extract other graph from this graph.
    
    After calling this function, self.isdisjoint(other) will return True. All edges that become dangling from node
    removal are also removed.
    &#34;&#34;&#34;
    for node in other.nodes:
        self.removeNode(node)</code></pre>
</details>
</dd>
<dt id="nfb_studio.widgets.scheme.graph.Graph.merge"><code class="name flex">
<span>def <span class="ident">merge</span></span>(<span>self, other)</span>
</code></dt>
<dd>
<section class="desc"><p>Merge other graph into this graph.</p>
<p>After calling this function, other.issubset(self) will return True.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def merge(self, other: AbstractGraph):
    &#34;&#34;&#34;Merge other graph into this graph.
    
    After calling this function, other.issubset(self) will return True.
    &#34;&#34;&#34;
    self.nodes.update(other.nodes)
    self.edges.update(other.edges)</code></pre>
</details>
</dd>
<dt id="nfb_studio.widgets.scheme.graph.Graph.removeEdge"><code class="name flex">
<span>def <span class="ident">removeEdge</span></span>(<span>self, edge)</span>
</code></dt>
<dd>
<section class="desc"><p>Remove an edge from this graph.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def removeEdge(self, edge: Edge):
    &#34;&#34;&#34;Remove an edge from this graph.&#34;&#34;&#34;
    self.edges.remove(edge)
    edge.detachAll()  # Disconnect from nodes that are still in this graph</code></pre>
</details>
</dd>
<dt id="nfb_studio.widgets.scheme.graph.Graph.removeNode"><code class="name flex">
<span>def <span class="ident">removeNode</span></span>(<span>self, node)</span>
</code></dt>
<dd>
<section class="desc"><p>Remove a node from this graph.</p>
<p>If a node is removed, all edges to or from that node are also removed.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def removeNode(self, node: Node):
    &#34;&#34;&#34;Remove a node from this graph.
    
    If a node is removed, all edges to or from that node are also removed.
    &#34;&#34;&#34;
    # Remove connected edges
    to_remove = []
    for edge in self.edges:
        if edge.sourceNode() == node or edge.targetNode() == node:
            to_remove.append(edge)
    
    for edge in to_remove:
        self.removeEdge(edge)

    # Remove the node
    self.nodes.remove(node)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="nfb_studio.widgets.scheme.graph.AbstractGraph" href="#nfb_studio.widgets.scheme.graph.AbstractGraph">AbstractGraph</a></b></code>:
<ul class="hlist">
<li><code><a title="nfb_studio.widgets.scheme.graph.AbstractGraph.boundingRect" href="#nfb_studio.widgets.scheme.graph.AbstractGraph.boundingRect">boundingRect</a></code></li>
<li><code><a title="nfb_studio.widgets.scheme.graph.AbstractGraph.findNode" href="#nfb_studio.widgets.scheme.graph.AbstractGraph.findNode">findNode</a></code></li>
<li><code><a title="nfb_studio.widgets.scheme.graph.AbstractGraph.isdisjoint" href="#nfb_studio.widgets.scheme.graph.AbstractGraph.isdisjoint">isdisjoint</a></code></li>
<li><code><a title="nfb_studio.widgets.scheme.graph.AbstractGraph.issubset" href="#nfb_studio.widgets.scheme.graph.AbstractGraph.issubset">issubset</a></code></li>
<li><code><a title="nfb_studio.widgets.scheme.graph.AbstractGraph.issuperset" href="#nfb_studio.widgets.scheme.graph.AbstractGraph.issuperset">issuperset</a></code></li>
<li><code><a title="nfb_studio.widgets.scheme.graph.AbstractGraph.moveBy" href="#nfb_studio.widgets.scheme.graph.AbstractGraph.moveBy">moveBy</a></code></li>
<li><code><a title="nfb_studio.widgets.scheme.graph.AbstractGraph.selectAll" href="#nfb_studio.widgets.scheme.graph.AbstractGraph.selectAll">selectAll</a></code></li>
<li><code><a title="nfb_studio.widgets.scheme.graph.AbstractGraph.selection" href="#nfb_studio.widgets.scheme.graph.AbstractGraph.selection">selection</a></code></li>
<li><code><a title="nfb_studio.widgets.scheme.graph.AbstractGraph.wideSelection" href="#nfb_studio.widgets.scheme.graph.AbstractGraph.wideSelection">wideSelection</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="nfb_studio.widgets.scheme.graph.GraphSnapshot"><code class="flex name class">
<span>class <span class="ident">GraphSnapshot</span></span>
<span>(</span><span>nodes=None, edges=None)</span>
</code></dt>
<dd>
<section class="desc"><p>A static reference to a part of a graph. Contains a frozenset of nodes and a frozenset of edges.</p>
<p>A snapshot is not meant to be edited.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class GraphSnapshot(AbstractGraph):
    &#34;&#34;&#34;A static reference to a part of a graph. Contains a frozenset of nodes and a frozenset of edges.

    A snapshot is not meant to be edited.
    &#34;&#34;&#34;
    def __init__(self, nodes=None, edges=None):
        super().__init__()

        self.nodes = nodes or frozenset()
        self.edges = edges or frozenset()

    # def serialize(self) -&gt; dict  # Inherited from AbstractGraph

    def deserialize(self, data: dict):
        &#34;&#34;&#34;Deserialize this object from a dict of data.
        
        This functions deserializes by loading data into a mutable Graph, then freezing it in a frozenset.
        &#34;&#34;&#34;
        g = Graph()
        g.deserialize(data)

        self.nodes = frozenset(g.nodes)
        self.edges = frozenset(g.edges)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="nfb_studio.widgets.scheme.graph.AbstractGraph" href="#nfb_studio.widgets.scheme.graph.AbstractGraph">AbstractGraph</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="nfb_studio.widgets.scheme.graph.GraphSnapshot.deserialize"><code class="name flex">
<span>def <span class="ident">deserialize</span></span>(<span>self, data)</span>
</code></dt>
<dd>
<section class="desc"><p>Deserialize this object from a dict of data.</p>
<p>This functions deserializes by loading data into a mutable Graph, then freezing it in a frozenset.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def deserialize(self, data: dict):
    &#34;&#34;&#34;Deserialize this object from a dict of data.
    
    This functions deserializes by loading data into a mutable Graph, then freezing it in a frozenset.
    &#34;&#34;&#34;
    g = Graph()
    g.deserialize(data)

    self.nodes = frozenset(g.nodes)
    self.edges = frozenset(g.edges)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="nfb_studio.widgets.scheme.graph.AbstractGraph" href="#nfb_studio.widgets.scheme.graph.AbstractGraph">AbstractGraph</a></b></code>:
<ul class="hlist">
<li><code><a title="nfb_studio.widgets.scheme.graph.AbstractGraph.boundingRect" href="#nfb_studio.widgets.scheme.graph.AbstractGraph.boundingRect">boundingRect</a></code></li>
<li><code><a title="nfb_studio.widgets.scheme.graph.AbstractGraph.findNode" href="#nfb_studio.widgets.scheme.graph.AbstractGraph.findNode">findNode</a></code></li>
<li><code><a title="nfb_studio.widgets.scheme.graph.AbstractGraph.isdisjoint" href="#nfb_studio.widgets.scheme.graph.AbstractGraph.isdisjoint">isdisjoint</a></code></li>
<li><code><a title="nfb_studio.widgets.scheme.graph.AbstractGraph.issubset" href="#nfb_studio.widgets.scheme.graph.AbstractGraph.issubset">issubset</a></code></li>
<li><code><a title="nfb_studio.widgets.scheme.graph.AbstractGraph.issuperset" href="#nfb_studio.widgets.scheme.graph.AbstractGraph.issuperset">issuperset</a></code></li>
<li><code><a title="nfb_studio.widgets.scheme.graph.AbstractGraph.moveBy" href="#nfb_studio.widgets.scheme.graph.AbstractGraph.moveBy">moveBy</a></code></li>
<li><code><a title="nfb_studio.widgets.scheme.graph.AbstractGraph.selectAll" href="#nfb_studio.widgets.scheme.graph.AbstractGraph.selectAll">selectAll</a></code></li>
<li><code><a title="nfb_studio.widgets.scheme.graph.AbstractGraph.selection" href="#nfb_studio.widgets.scheme.graph.AbstractGraph.selection">selection</a></code></li>
<li><code><a title="nfb_studio.widgets.scheme.graph.AbstractGraph.wideSelection" href="#nfb_studio.widgets.scheme.graph.AbstractGraph.wideSelection">wideSelection</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="nfb_studio.widgets.scheme" href="index.html">nfb_studio.widgets.scheme</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="nfb_studio.widgets.scheme.graph.AbstractGraph" href="#nfb_studio.widgets.scheme.graph.AbstractGraph">AbstractGraph</a></code></h4>
<ul class="two-column">
<li><code><a title="nfb_studio.widgets.scheme.graph.AbstractGraph.boundingRect" href="#nfb_studio.widgets.scheme.graph.AbstractGraph.boundingRect">boundingRect</a></code></li>
<li><code><a title="nfb_studio.widgets.scheme.graph.AbstractGraph.findNode" href="#nfb_studio.widgets.scheme.graph.AbstractGraph.findNode">findNode</a></code></li>
<li><code><a title="nfb_studio.widgets.scheme.graph.AbstractGraph.isdisjoint" href="#nfb_studio.widgets.scheme.graph.AbstractGraph.isdisjoint">isdisjoint</a></code></li>
<li><code><a title="nfb_studio.widgets.scheme.graph.AbstractGraph.issubset" href="#nfb_studio.widgets.scheme.graph.AbstractGraph.issubset">issubset</a></code></li>
<li><code><a title="nfb_studio.widgets.scheme.graph.AbstractGraph.issuperset" href="#nfb_studio.widgets.scheme.graph.AbstractGraph.issuperset">issuperset</a></code></li>
<li><code><a title="nfb_studio.widgets.scheme.graph.AbstractGraph.moveBy" href="#nfb_studio.widgets.scheme.graph.AbstractGraph.moveBy">moveBy</a></code></li>
<li><code><a title="nfb_studio.widgets.scheme.graph.AbstractGraph.selectAll" href="#nfb_studio.widgets.scheme.graph.AbstractGraph.selectAll">selectAll</a></code></li>
<li><code><a title="nfb_studio.widgets.scheme.graph.AbstractGraph.selection" href="#nfb_studio.widgets.scheme.graph.AbstractGraph.selection">selection</a></code></li>
<li><code><a title="nfb_studio.widgets.scheme.graph.AbstractGraph.serialize" href="#nfb_studio.widgets.scheme.graph.AbstractGraph.serialize">serialize</a></code></li>
<li><code><a title="nfb_studio.widgets.scheme.graph.AbstractGraph.wideSelection" href="#nfb_studio.widgets.scheme.graph.AbstractGraph.wideSelection">wideSelection</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="nfb_studio.widgets.scheme.graph.Graph" href="#nfb_studio.widgets.scheme.graph.Graph">Graph</a></code></h4>
<ul class="two-column">
<li><code><a title="nfb_studio.widgets.scheme.graph.Graph.addEdge" href="#nfb_studio.widgets.scheme.graph.Graph.addEdge">addEdge</a></code></li>
<li><code><a title="nfb_studio.widgets.scheme.graph.Graph.addNode" href="#nfb_studio.widgets.scheme.graph.Graph.addNode">addNode</a></code></li>
<li><code><a title="nfb_studio.widgets.scheme.graph.Graph.clear" href="#nfb_studio.widgets.scheme.graph.Graph.clear">clear</a></code></li>
<li><code><a title="nfb_studio.widgets.scheme.graph.Graph.connect_nodes" href="#nfb_studio.widgets.scheme.graph.Graph.connect_nodes">connect_nodes</a></code></li>
<li><code><a title="nfb_studio.widgets.scheme.graph.Graph.deserialize" href="#nfb_studio.widgets.scheme.graph.Graph.deserialize">deserialize</a></code></li>
<li><code><a title="nfb_studio.widgets.scheme.graph.Graph.disconnect_nodes" href="#nfb_studio.widgets.scheme.graph.Graph.disconnect_nodes">disconnect_nodes</a></code></li>
<li><code><a title="nfb_studio.widgets.scheme.graph.Graph.extract" href="#nfb_studio.widgets.scheme.graph.Graph.extract">extract</a></code></li>
<li><code><a title="nfb_studio.widgets.scheme.graph.Graph.merge" href="#nfb_studio.widgets.scheme.graph.Graph.merge">merge</a></code></li>
<li><code><a title="nfb_studio.widgets.scheme.graph.Graph.removeEdge" href="#nfb_studio.widgets.scheme.graph.Graph.removeEdge">removeEdge</a></code></li>
<li><code><a title="nfb_studio.widgets.scheme.graph.Graph.removeNode" href="#nfb_studio.widgets.scheme.graph.Graph.removeNode">removeNode</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="nfb_studio.widgets.scheme.graph.GraphSnapshot" href="#nfb_studio.widgets.scheme.graph.GraphSnapshot">GraphSnapshot</a></code></h4>
<ul class="">
<li><code><a title="nfb_studio.widgets.scheme.graph.GraphSnapshot.deserialize" href="#nfb_studio.widgets.scheme.graph.GraphSnapshot.deserialize">deserialize</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.7.5</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>